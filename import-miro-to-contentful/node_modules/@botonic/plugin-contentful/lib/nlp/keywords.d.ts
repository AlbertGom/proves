import { Locale } from './locales';
import { NormalizedUtterance, Normalizer, Word } from './normalizer';
import { SimilarWordResult } from './similar-words';
/**
 * May contain multiple words
 * TODO consider storing as a list of new Token class instances', each with a raw and stem fields
 */
export declare class Keyword {
    readonly words: Word[];
    readonly hasOnlyStopWords: boolean;
    /** Lowercase raw keyword */
    readonly raw: string;
    /**
     * If hasOnlyStopWords == false, the stems of the non stopWords (eg. buy a shirt => buy shirt)
     * Otherwise, it contains the tokens of the stopwords (how are you => how are you)
     */
    readonly matchString: string;
    constructor(raw: string, words: Word[], hasOnlyStopWords: boolean);
    static fromUtterance(rawKeyword: string, locale: Locale, normalizer: Normalizer): Keyword;
    splitInWords(): Keyword[];
    joinedTokens(withStopWords: boolean): string;
}
export declare class CandidateWithKeywords<M> {
    readonly owner: M;
    readonly keywords: Keyword[];
    constructor(owner: M, keywords: Keyword[]);
}
export declare enum MatchType {
    /** After removing stop words, spaces and word endings, the input text must only contain the keywords*/
    ONLY_KEYWORDS_FOUND = 0,
    /** The keyword may be preceded and followed by other words */
    KEYWORDS_AND_OTHERS_FOUND = 1,
    /** All the words in the keyword must appear on input text, even if mixed up with other words*/
    ALL_WORDS_IN_KEYWORDS_MIXED_UP = 2
}
export declare const MATCH_TYPES: MatchType[];
export declare enum SortType {
    NONE = 0,
    LENGTH = 1
}
export declare class KeywordsOptions {
    readonly maxDistance: number;
    readonly similarWordsMinMatchLength: number;
    readonly resultsSortType: SortType;
    constructor(maxDistance?: number, similarWordsMinMatchLength?: number, resultsSortType?: SortType);
}
export declare class KeywordsParser<M> {
    readonly locale: Locale;
    readonly matchType: MatchType;
    readonly normalizer: Normalizer;
    readonly options: KeywordsOptions;
    private readonly candidates;
    private readonly similar;
    constructor(locale: Locale, matchType: MatchType, normalizer: Normalizer, options: KeywordsOptions);
    /**
     *
     * @param candidate
     * @param rawKeywords a candidate may be associated to multiple keywords, and each one of them may contain multiple
     * words (which must appear together in the same order). The keywords will be stemmed.
     * @throws EmptyTextException
     */
    addCandidate(candidate: M, rawKeywords: string[]): void;
    findCandidatesWithKeywordsAt(utterance: NormalizedUtterance): SimilarWordResult<M>[];
    private sort;
}
