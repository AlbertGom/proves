"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeywordsParser = exports.KeywordsOptions = exports.SortType = exports.MATCH_TYPES = exports.MatchType = exports.CandidateWithKeywords = exports.Keyword = void 0;
const normalizer_1 = require("./normalizer");
const similar_words_1 = require("./similar-words");
/**
 * May contain multiple words
 * TODO consider storing as a list of new Token class instances', each with a raw and stem fields
 */
class Keyword {
    constructor(raw, words, hasOnlyStopWords) {
        this.words = words;
        this.hasOnlyStopWords = hasOnlyStopWords;
        if (hasOnlyStopWords) {
            this.matchString = normalizer_1.Word.joinedTokens(words, true);
        }
        else {
            this.matchString = words
                .filter(w => !w.isStopWord)
                .map(w => w.stem)
                .join(' ');
        }
        this.raw = raw.trim().toLowerCase();
    }
    static fromUtterance(rawKeyword, locale, normalizer) {
        const normalized = normalizer.normalize(locale, rawKeyword);
        return new Keyword(rawKeyword, normalized.words, normalized.hasOnlyStopWords());
    }
    splitInWords() {
        if (this.words.length == 1) {
            return [this];
        }
        return this.words.map(w => new Keyword(w.token, [w], w.isStopWord));
    }
    joinedTokens(withStopWords) {
        return normalizer_1.Word.joinedTokens(this.words, withStopWords);
    }
}
exports.Keyword = Keyword;
class CandidateWithKeywords {
    constructor(owner, keywords) {
        this.owner = owner;
        this.keywords = keywords;
    }
}
exports.CandidateWithKeywords = CandidateWithKeywords;
var MatchType;
(function (MatchType) {
    /** After removing stop words, spaces and word endings, the input text must only contain the keywords*/
    MatchType[MatchType["ONLY_KEYWORDS_FOUND"] = 0] = "ONLY_KEYWORDS_FOUND";
    /** The keyword may be preceded and followed by other words */
    MatchType[MatchType["KEYWORDS_AND_OTHERS_FOUND"] = 1] = "KEYWORDS_AND_OTHERS_FOUND";
    /** All the words in the keyword must appear on input text, even if mixed up with other words*/
    MatchType[MatchType["ALL_WORDS_IN_KEYWORDS_MIXED_UP"] = 2] = "ALL_WORDS_IN_KEYWORDS_MIXED_UP";
})(MatchType = exports.MatchType || (exports.MatchType = {}));
exports.MATCH_TYPES = Object.values(MatchType).map(m => m);
var SortType;
(function (SortType) {
    SortType[SortType["NONE"] = 0] = "NONE";
    SortType[SortType["LENGTH"] = 1] = "LENGTH";
})(SortType = exports.SortType || (exports.SortType = {}));
class KeywordsOptions {
    constructor(maxDistance = 1, similarWordsMinMatchLength = 3, resultsSortType = SortType.LENGTH) {
        this.maxDistance = maxDistance;
        this.similarWordsMinMatchLength = similarWordsMinMatchLength;
        this.resultsSortType = resultsSortType;
    }
}
exports.KeywordsOptions = KeywordsOptions;
class KeywordsParser {
    constructor(locale, matchType, normalizer, options) {
        this.locale = locale;
        this.matchType = matchType;
        this.normalizer = normalizer;
        this.options = options;
        this.candidates = [];
        this.similar = new similar_words_1.SimilarWordFinder(true, options.similarWordsMinMatchLength);
    }
    /**
     *
     * @param candidate
     * @param rawKeywords a candidate may be associated to multiple keywords, and each one of them may contain multiple
     * words (which must appear together in the same order). The keywords will be stemmed.
     * @throws EmptyTextException
     */
    addCandidate(candidate, rawKeywords) {
        const stemmedKeywords = rawKeywords.map(rawKeyword => {
            return Keyword.fromUtterance(rawKeyword, this.locale, this.normalizer);
        });
        const candidateWithK = new CandidateWithKeywords(candidate, stemmedKeywords);
        this.candidates.push(candidateWithK);
        this.similar.addCandidate(candidateWithK);
    }
    findCandidatesWithKeywordsAt(utterance) {
        const results = this.similar.find(this.matchType, utterance, this.options.maxDistance);
        return this.sort(results);
    }
    sort(results) {
        if (this.options.resultsSortType === SortType.NONE) {
            return results;
        }
        return results.sort((r1, r2) => r2.match.length - r1.match.length);
    }
}
exports.KeywordsParser = KeywordsParser;
//# sourceMappingURL=keywords.js.map