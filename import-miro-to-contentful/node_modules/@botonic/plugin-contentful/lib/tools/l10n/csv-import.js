"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecordFixer = exports.CsvImport = exports.recordId = exports.PARSE_OPTIONS = void 0;
const csv_parse_1 = __importDefault(require("csv-parse"));
const fs = __importStar(require("fs"));
const cms_1 = require("../../cms");
const fields_1 = require("../../manage-cms/fields");
const strings_1 = require("../../nlp/util/strings");
exports.PARSE_OPTIONS = {
    escape: '"',
    delimiter: ';',
    quote: '"',
    columns: ['Model', 'Code', 'Id', 'Field', 'from', 'to'],
    relaxColumnCountMore: true,
    bom: true,
};
function recordId(record) {
    return `'${record.Id}/${record.Code}'`;
}
exports.recordId = recordId;
class CsvImport {
    constructor(importer, options = {}) {
        this.importer = importer;
        this.options = options;
    }
    import(options) {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            const parse = new csv_parse_1.default.Parser(exports.PARSE_OPTIONS);
            const reader = fs.createReadStream(options.fname).pipe(parse);
            const header = new CsvImport.HeaderSkipper();
            const records = [];
            try {
                for (var _b = __asyncValues(reader), _c; _c = yield _b.next(), !_c.done;) {
                    const record = _c.value;
                    if (header.skipFirst(record)) {
                        this.extraColumnsMustBeEmpty(record);
                        continue;
                    }
                    records.push(record);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.sortRecords(records);
            yield this.importRecords(options, records);
        });
    }
    sortRecords(records) {
        records.sort((r1, r2) => {
            const comp = r1.Model.localeCompare(r2.Model);
            if (comp !== 0)
                return comp;
            return r1.Code.localeCompare(r2.Code);
        });
    }
    importRecords(options, records) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            for (const record of records) {
                const recordId = `'${record.Model}' field '${record.Code.trim() || record.Id}.${record.Field}'`;
                if ((_a = options.ignoreContentIds) === null || _a === void 0 ? void 0 : _a.includes(record.Id)) {
                    console.info(`Skipping ${recordId}`);
                    continue;
                }
                if (record.from &&
                    !record.to &&
                    record.Field != fields_1.ContentFieldType.SHORT_TEXT //see ImportContentUpdater.mustBeDeleted
                ) {
                    console.warn(`Missing translation for ${recordId}`);
                    console.warn('To remove the content for a locale, remove the keywords and any link to it');
                }
                if (this.options.nameFilter && !this.options.nameFilter(record.Code)) {
                    continue;
                }
                console.log(`Importing ${recordId}`);
                yield this.importer.consume(record);
            }
            yield this.importer.flush();
        });
    }
    extraColumnsMustBeEmpty(record) {
        const cols = exports.PARSE_OPTIONS.columns;
        if (Object.keys(record).length == cols.length) {
            return;
        }
        for (let i = cols.length; i < Object.keys(record).length; i++) {
            if (Object.values(i)) {
                throw new cms_1.CmsException('Too many columns');
            }
        }
    }
}
exports.CsvImport = CsvImport;
CsvImport.HeaderSkipper = class {
    constructor() {
        this.first = true;
    }
    skipFirst(record) {
        if (this.first) {
            this.first = false;
            if (record.Model == 'Model') {
                console.log('Skipping header');
                return true;
            }
            console.error('No header found. Parsing fist line as a normal line');
        }
        return false;
    }
};
class RecordFixer {
    constructor(record) {
        this.record = record;
        this.field = fields_1.CONTENT_FIELDS.get(record.Field);
    }
    fix() {
        this.fixCapitals();
        this.fixExcelNewLine();
        if (this.field.valueType == fields_1.ContentFieldValueType.STRING_ARRAY) {
            this.checkKeywordLen();
            this.removeLastEmptyItem();
        }
    }
    fixCapitals() {
        const firstChar = this.record.Model[0];
        if (firstChar === firstChar.toLowerCase()) {
            return;
        }
        this.record.Model = this.record.Model.toLowerCase();
    }
    fixTrimmingQuotes() {
        //it's typical to forget a " at the first character of the value
        this.record.to = strings_1.trim(this.record.to, '" ');
    }
    fixExcelNewLine() {
        //https://bugs.documentfoundation.org/show_bug.cgi?id=118470
        this.record.to = strings_1.replaceAll(this.record.to, '_x000D_', '');
    }
    fixStringArraySeparators(stringArray) {
        for (const c of ',.?') {
            if (stringArray.indexOf(c) >= 0) {
                this.complain(`... Replacing '${c}' with ;`);
                stringArray = strings_1.replaceAll(stringArray, c, ';');
            }
        }
        return stringArray;
    }
    checkKeywordLen() {
        if (this.field.fieldType == fields_1.ContentFieldType.KEYWORDS) {
            const fromLen = this.field.parse(this.record.from).length;
            const toLen = this.field.parse(this.record.to).length;
            if (toLen != fromLen || fromLen == 1) {
                this.complain(`'From' has ${fromLen} keywords:\n${this.record.from}\n ` +
                    `but 'to' has ${toLen}:\n${this.record.to}`);
                this.record.to = this.fixStringArraySeparators(this.record.to);
            }
        }
    }
    removeLastEmptyItem() {
        const emptyLastItem = /; *$/;
        if (emptyLastItem.exec(this.record.to)) {
            this.complain('Removing final empty keyword');
            this.record.to = this.record.to.replace(emptyLastItem, '');
        }
    }
    complain(msg) {
        console.error(`Problem in ${this.record.Id} / ${this.record.Code}: ${msg}`);
    }
}
exports.RecordFixer = RecordFixer;
//# sourceMappingURL=csv-import.js.map