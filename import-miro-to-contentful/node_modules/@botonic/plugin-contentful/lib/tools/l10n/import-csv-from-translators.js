"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportType = void 0;
const message_visitors_1 = require("../../cms/visitors/message-visitors");
const factories_1 = require("../../contentful/factories");
const content_deleter_1 = require("../../manage-cms/content-deleter");
const enums_1 = require("../../util/enums");
const csv_import_1 = require("./csv-import");
const import_updater_1 = require("./import-updater");
const reference_field_duplicator_1 = require("./reference-field-duplicator");
function readCsvForTranslators(manageCms, cms, info, context, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const reachableFromButtons = new message_visitors_1.MessageContentInverseTraverser(cms, info, context, { ignoreFollowUps: true });
        const deleter = new content_deleter_1.ContentDeleter(manageCms, reachableFromButtons, context);
        const updater = new import_updater_1.ImportContentUpdater(manageCms, cms, info, context, deleter);
        const fieldImporter = new import_updater_1.ImportRecordReducer(updater, {
            resumeErrors: options.resumeErrors,
        });
        const importer = new csv_import_1.CsvImport(fieldImporter);
        yield importer.import(options);
    });
}
var ImportType;
(function (ImportType) {
    ImportType["DRY"] = "DRY";
    ImportType["NO_OVERWRITE"] = "NO_OVERWRITE";
    ImportType["OVERWRITE"] = "OVERWRITE";
    ImportType["OVERWRITE_AND_PUBLISH"] = "OVERWRITE_AND_PUBLISH";
})(ImportType = exports.ImportType || (exports.ImportType = {}));
if (process.argv.length < 10 || process.argv[2] == '--help') {
    console.log(`Usage: space_id environment delivery_token mgmnt_token locale filename [${Object.values(ImportType).join('|')}] duplicate_references`);
    console.log(`duplicate_references: if 'true', it will copy also the buttons, element images and assets of all contents ` +
        `(not only the ones in the input file)`);
    // eslint-disable-next-line no-process-exit
    process.exit(1);
}
const spaceId = process.argv[2];
const environment = process.argv[3];
const deliverAccessToken = process.argv[4];
const manageAccessToken = process.argv[5];
const locale = process.argv[6];
const fileName = process.argv[7];
const importType = String(process.argv[8]);
if (!enums_1.isOfType(importType, ImportType)) {
    throw Error(`${importType} is not a valid value`);
}
const duplicateReferences = process.argv[9].toLowerCase() == 'true'
    ? true
    : process.argv[9].toLowerCase() == 'false'
        ? false
        : undefined;
if (duplicateReferences == undefined) {
    throw Error("duplicateReferences argument must be 'true' or 'false'");
}
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (importType == ImportType.NO_OVERWRITE) {
                console.warn('Contents will be left in preview mode. Publish them from contentful.com');
            }
            const manageContext = {
                locale,
                preview: importType == ImportType.OVERWRITE,
                dryRun: importType == ImportType.DRY,
                allowOverwrites: [
                    ImportType.OVERWRITE,
                    ImportType.OVERWRITE_AND_PUBLISH,
                    ImportType.DRY,
                ].includes(importType),
            };
            const cmsOptions = {
                spaceId,
                accessToken: deliverAccessToken,
                environment,
                resumeErrors: true,
            };
            const cms = factories_1.createCms(cmsOptions);
            const info = factories_1.createCmsInfo(cmsOptions);
            const manageCms = factories_1.createManageCms({
                spaceId,
                accessToken: manageAccessToken,
                environment,
            });
            if (duplicateReferences) {
                console.log('Duplicating reference fields');
                yield duplicateReferenceFields(manageCms, cms, info, manageContext);
            }
            yield readCsvForTranslators(manageCms, cms, info, manageContext, {
                fname: fileName,
                resumeErrors: true,
                ignoreContentIds: [],
            });
            console.log('done');
        }
        catch (e) {
            console.error(e);
        }
        if (importType == ImportType.OVERWRITE) {
            console.log("Remember that you'll need to publish the changed contents from contentful.com");
        }
    });
}
function duplicateReferenceFields(manageCms, cms, info, manageContext) {
    return __awaiter(this, void 0, void 0, function* () {
        const referenceDuplicator = new reference_field_duplicator_1.ReferenceFieldDuplicator(cms, info, manageCms, manageContext);
        yield referenceDuplicator.duplicateReferenceFields();
        yield referenceDuplicator.duplicateAssetFiles();
    });
}
// void tells linters that we don't want to wait for promise
// await in main requires esnext
void main();
//# sourceMappingURL=import-csv-from-translators.js.map