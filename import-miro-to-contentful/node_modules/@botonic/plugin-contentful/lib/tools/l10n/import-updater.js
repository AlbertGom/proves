"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportContentUpdater = exports.ImportRecordReducer = exports.ContentToImport = void 0;
const cms_1 = require("../../cms");
const exceptions_1 = require("../../cms/exceptions");
const message_visitors_1 = require("../../cms/visitors/message-visitors");
const manage_cms_1 = require("../../manage-cms");
const fields_1 = require("../../manage-cms/fields");
const arrays_1 = require("../../util/arrays");
const enums_1 = require("../../util/enums");
const csv_import_1 = require("./csv-import");
const fields_2 = require("./fields");
class ContentToImport {
    constructor(contentId, name, fields) {
        this.contentId = contentId;
        this.name = name;
        this.fields = fields;
    }
    toString() {
        const fields = Object.keys(this.fields)
            .map(k => `${k}:${String(this.fields[k])}`)
            .join('/');
        return [this.contentId, this.name, fields].join('/');
    }
}
exports.ContentToImport = ContentToImport;
/**
 * Reduce all the records read from a csv into ContentToImport's
 * and delegates to ContentUpdater.
 * It also checks consistency of all records of a given content
 */
class ImportRecordReducer {
    constructor(importer, options) {
        this.importer = importer;
        this.options = options;
        this.pending = [];
    }
    consume(record) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!enums_1.isOfType(record.Model, cms_1.ContentType)) {
                console.error(`Bad model '${String(record.Model)}'. Should be one of ${String(Object.values(cms_1.BotonicContentType))}`);
                return;
            }
            const field = fields_1.CONTENT_FIELDS.get(record.Field);
            if (!field) {
                console.error(`Bad field '${record.Field}'`);
                return;
            }
            const last = this.last();
            if (last) {
                if (last.Id == record.Id) {
                    if (!this.checkLast(record, last)) {
                        return;
                    }
                }
                else {
                    yield this.flush();
                }
            }
            this.pending.push(record);
        });
    }
    checkLast(record, last) {
        let diffField = undefined;
        if (last.Model != record.Model) {
            diffField = 'model';
        }
        if (last.Code != record.Code) {
            diffField = 'code';
        }
        if (diffField) {
            console.error(`Records ${csv_import_1.recordId(record)} & ${csv_import_1.recordId(last)} with same id have different ${diffField}`);
            return false;
        }
        return true;
    }
    flush() {
        return __awaiter(this, void 0, void 0, function* () {
            const last = this.last();
            if (!last)
                return;
            const fields = {};
            for (const r of this.pending) {
                fields[r.Field] = this.value(r);
            }
            const contentImport = new ContentToImport(cms_1.ContentId.create(last.Model, last.Id), last.Code, fields);
            try {
                yield this.importer.update(contentImport);
            }
            catch (e) {
                if (this.options.resumeErrors) {
                    const msgs = new exceptions_1.ExceptionUnpacker().unpack(e).join('\n');
                    console.error(`Skipping after error when importing ${contentImport.contentId.toString()}:\n${msgs}`);
                }
                else {
                    throw e;
                }
            }
            this.pending = [];
        });
    }
    last() {
        if (!this.pending.length)
            return undefined;
        return this.pending[this.pending.length - 1];
    }
    value(record) {
        const field = fields_1.CONTENT_FIELDS.get(record.Field);
        const fixer = new csv_import_1.RecordFixer(record);
        fixer.fix();
        return field.parse(record.to);
    }
}
exports.ImportRecordReducer = ImportRecordReducer;
/**
 * - If ContentToImport only has shortText and its value is empty,
 * it'll assume that the content needs to be removed for this locale.
 * Its fields will be deleted and all buttons which target it will be removed.
 * - Otherwise, the specified fields will be overwritten
 */
class ImportContentUpdater {
    constructor(manageCms, cms, info, context, deleter) {
        this.manageCms = manageCms;
        this.cms = cms;
        this.info = info;
        this.context = context;
        this.deleter = deleter;
    }
    update(content) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.mustBeDeleted(content)) {
                yield this.deleter.deleteContent(content.contentId, content.name);
            }
            else {
                yield this.updateFields(content);
            }
        });
    }
    updateFields(content) {
        return __awaiter(this, void 0, void 0, function* () {
            const newVal = yield this.manageCms.updateFields(this.context, content.contentId, content.fields);
            yield this.warnMissingFields(content, newVal);
        });
    }
    contentTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            return arrays_1.andArrays(fields_2.EXPORTABLE_CONTENT_TYPES, yield this.info.contentTypes());
        });
    }
    warnMissingFields(content, newVals) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.defaultLocaleContents) {
                this.defaultLocaleContents = yield message_visitors_1.allContents(this.cms, {}, yield this.contentTypes());
            }
            for (const field of fields_1.getFieldsForContentType(content.contentId.model)) {
                const f = fields_1.CONTENT_FIELDS.get(field);
                if (![
                    fields_1.ContentFieldValueType.STRING,
                    fields_1.ContentFieldValueType.STRING_ARRAY,
                ].includes(f.valueType)) {
                    continue;
                }
                const defaultLocaleContent = this.defaultLocaleContents.find(c => c.id == content.contentId.id);
                if (!content.fields[field] &&
                    defaultLocaleContent &&
                    f.isNotEmptyAt(defaultLocaleContent)) {
                    console.warn(`Missing field '${field}' for ${content.contentId.toString()} (${content.name})`);
                }
            }
        });
    }
    mustBeDeleted(content) {
        return (enums_1.isOfType(content.contentId.model, cms_1.MessageContentType) &&
            Object.keys(content.fields).length === 1 &&
            manage_cms_1.ContentFieldType.SHORT_TEXT in content.fields &&
            content.fields[manage_cms_1.ContentFieldType.SHORT_TEXT].trim() === '');
    }
}
exports.ImportContentUpdater = ImportContentUpdater;
//# sourceMappingURL=import-updater.js.map