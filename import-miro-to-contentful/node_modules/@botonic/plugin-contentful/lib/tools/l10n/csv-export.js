"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.create_stringifier = exports.ContentToCsvLines = exports.CsvExport = exports.skipEmptyStrings = void 0;
const csv_stringify_1 = __importDefault(require("csv-stringify"));
const fs = __importStar(require("fs"));
const sort_stream_1 = __importDefault(require("sort-stream"));
const stream = __importStar(require("stream"));
const util_1 = require("util");
const cms_1 = require("../../cms");
const exceptions_1 = require("../../cms/exceptions");
const index_1 = require("../../index");
const fields_1 = require("../../manage-cms/fields");
const finished = util_1.promisify(stream.finished);
const skipEmptyStrings = (str) => Boolean(str && str.trim());
exports.skipEmptyStrings = skipEmptyStrings;
/***
 * @see I18nEntryTraverser limitations.
 * It should be reimplemented without traversing field references.
 * Uses https://csv.js.org/stringify/api/
 */
class CsvExport {
    constructor(options, postprocessor = (field) => field) {
        this.options = options;
        this.toFields = new ContentToCsvLines(options, postprocessor);
    }
    static sortRows(a, b) {
        for (const i in a) {
            const cmp = a[i].localeCompare(b[i]);
            if (cmp != 0) {
                return cmp;
            }
        }
        return 0;
    }
    write(fname, cms, locale) {
        return __awaiter(this, void 0, void 0, function* () {
            const stringifier = create_stringifier();
            const readable = stream.Readable.from(this.generate(cms, locale));
            const writable = readable
                .pipe(sort_stream_1.default(CsvExport.sortRows))
                .pipe(stringifier)
                .pipe(fs.createWriteStream(fname));
            return this.toPromise(writable);
        });
    }
    toPromise(writable) {
        return __awaiter(this, void 0, void 0, function* () {
            return finished(writable);
        });
    }
    generate(cms, from) {
        return __asyncGenerator(this, arguments, function* generate_1() {
            // TODO use CmsInfo to restrict the types
            for (const model of [...cms_1.BOTONIC_CONTENT_TYPES, cms_1.ContentType.URL]) {
                console.log(`Exporting contents of type ${model}`);
                try {
                    const contents = yield __await(cms.contents(model, {
                        locale: from,
                        ignoreFallbackLocale: true,
                    }));
                    for (const content of contents) {
                        if (this.options.nameFilter &&
                            !this.options.nameFilter(content.name)) {
                            continue;
                        }
                        console.log('Exporting content', content.name.trim() || content.id);
                        for (const field of this.toFields.getCsvLines(content)) {
                            const TO_COLUMN = '';
                            yield yield __await([...field, TO_COLUMN]);
                        }
                    }
                }
                catch (e) {
                    if (e instanceof exceptions_1.ResourceTypeNotFoundCmsException) {
                        console.error(`The space has no model '${e.resourceType}'. Skipping it.`);
                    }
                }
            }
        });
    }
}
exports.CsvExport = CsvExport;
class ContentToCsvLines {
    constructor(options, postprocessor) {
        this.options = options;
        this.postprocessor = postprocessor;
    }
    getCsvLines(content) {
        const columns = [content.contentType, content.name, content.id];
        let fields = this.getFields(content);
        if (this.options.stringFilter) {
            fields = fields.filter(f => this.options.stringFilter(f.value));
        }
        const lines = fields.map(f => [...columns, f.name, f.value]);
        if (this.postprocessor) {
            const processed = fields.map(this.postprocessor);
            for (let i = 0; i < processed.length; i++) {
                if (processed[i].value != fields[i].value) {
                    lines[i].push(processed[i].value);
                }
            }
        }
        return lines;
    }
    getFields(content) {
        if (content instanceof index_1.Button) {
            return [new fields_1.I18nField(fields_1.ContentFieldType.TEXT, content.text)];
        }
        else if (content instanceof index_1.StartUp) {
            return [
                ...this.getCommonFields(content.common),
                new fields_1.I18nField(fields_1.ContentFieldType.TEXT, content.text),
            ];
        }
        else if (content instanceof cms_1.Text) {
            return [
                ...this.getCommonFields(content.common),
                new fields_1.I18nField(fields_1.ContentFieldType.TEXT, content.text),
            ];
        }
        else if (content instanceof index_1.Element) {
            return [
                new fields_1.I18nField(fields_1.ContentFieldType.TITLE, content.title),
                new fields_1.I18nField(fields_1.ContentFieldType.SUBTITLE, content.subtitle),
            ];
        }
        else if (content instanceof index_1.Url) {
            return [
                ...this.getCommonFields(content.common),
                new fields_1.I18nField(fields_1.ContentFieldType.URL, content.url),
            ];
        }
        else if (content instanceof index_1.TopContent) {
            return this.getCommonFields(content.common);
        }
        return [];
    }
    getCommonFields(common) {
        return [
            new fields_1.I18nField(fields_1.ContentFieldType.SHORT_TEXT, common.shortText),
            // TODO process value based on ContentField.valueType
            new fields_1.I18nField(fields_1.ContentFieldType.KEYWORDS, common.keywords.join(fields_1.ContentField.STRING_ARRAY_SEPARATOR)),
        ];
    }
}
exports.ContentToCsvLines = ContentToCsvLines;
function create_stringifier() {
    return csv_stringify_1.default({
        escape: '"',
        delimiter: ';',
        quote: '"',
        quoted: true,
        record_delimiter: 'windows',
        header: true,
        columns: ['Model', 'Code', 'Id', 'Field', 'From', 'To'],
    });
}
exports.create_stringifier = create_stringifier;
//# sourceMappingURL=csv-export.js.map