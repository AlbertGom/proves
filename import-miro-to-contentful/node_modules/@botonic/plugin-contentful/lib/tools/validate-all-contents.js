"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultContentsValidatorReports = exports.ContentsValidator = void 0;
const async_parallel_1 = require("async-parallel");
const cms_1 = require("../cms");
const exceptions_1 = require("../cms/exceptions");
const message_visitors_1 = require("../cms/visitors/message-visitors");
class ContentsValidator {
    /**
     *
     * @param onlyValidateReachable only validate searchable contents (with keywords) or
     * which are linked from other contents
     * @param initialContentIds contents to be validated even if they're not
     * reachable
     */
    constructor(cms, report = new DefaultContentsValidatorReports(), onlyValidateReachable = true, initialContentIds = []) {
        this.cms = cms;
        this.report = report;
        this.onlyValidateReachable = onlyValidateReachable;
        this.initialContentIds = initialContentIds;
    }
    /**
     * Deliver all TopContent's to validate that they won't fail in production.
     * A content delivery might fail if:
     * - It has a link to a deleted content
     * - There are infinite loops
     * - There's a bug on the CMS plugin
     * - An URL has empty URL empty
     */
    validateAllTopContents(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const messageContents = yield this.cacheMessageContents(context);
            const messageContentsToValidate = this.onlyValidateReachable
                ? yield this.reachableContents(messageContents, context)
                : messageContents;
            for (const c of messageContentsToValidate) {
                this.validate(c);
            }
        });
    }
    cacheMessageContents(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const messageContents = [];
            // TODO also validate non TopContent contents
            for (const model of cms_1.TOP_CONTENT_TYPES) {
                try {
                    // TODO use async to improve concurrency
                    const modelContents = yield this.cms.topContents(model, context);
                    for (const content of modelContents) {
                        if (content instanceof cms_1.MessageContent) {
                            messageContents.push(content);
                        }
                        else {
                            this.validate(content);
                        }
                    }
                }
                catch (e) {
                    this.processException(model, e);
                }
            }
            return messageContents;
        });
    }
    processException(model, e) {
        const resourceId = e instanceof cms_1.CmsException && e.resourceId;
        const multiError = this.getMultiError(e);
        if (multiError && !resourceId) {
            for (const e1 of multiError.list) {
                this.processException(model, e1);
            }
        }
        else {
            this.report.deliveryError(resourceId || new cms_1.ContentId(model, '??'), exceptions_1.ensureError(e));
        }
    }
    getMultiError(e) {
        if (e instanceof async_parallel_1.MultiError) {
            return e;
        }
        if (e instanceof cms_1.CmsException && e.reason instanceof async_parallel_1.MultiError) {
            return e.reason;
        }
        return undefined;
    }
    reachableContents(allContents, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const reachable = yield message_visitors_1.reachableFrom(this.cms, allContents, context);
            allContents.filter(c => c.isSearchable()).forEach(c => reachable.add(c));
            this.addInitialContents(allContents, reachable);
            return reachable;
        });
    }
    validate(content) {
        const res = content.validate();
        if (res) {
            this.report.validationError(content.contentId, res);
        }
        else {
            this.report.successfulValidation(content.contentId);
        }
    }
    addInitialContents(allContents, reachable) {
        if (this.initialContentIds.length == 0) {
            return;
        }
        for (const c of allContents) {
            if (this.initialContentIds.includes(c.id)) {
                reachable.add(c);
            }
        }
    }
}
exports.ContentsValidator = ContentsValidator;
class DefaultContentsValidatorReports {
    constructor(logErrors = true) {
        this.logErrors = logErrors;
        this.errors = [];
        this.successContents = [];
    }
    successfulValidation(resourceId) {
        this.successContents.push(resourceId);
    }
    deliveryError(resourceId, exception) {
        let msg = exception.message;
        if (exception instanceof cms_1.CmsException) {
            msg += exception.messageFromReason();
        }
        this.processError(resourceId, msg, true);
    }
    validationError(resourceId, error) {
        this.processError(resourceId, error, false);
    }
    processError(resourceId, msg, critical) {
        if (this.logErrors) {
            if (!msg.includes(resourceId.id)) {
                msg = `${resourceId.toString()}: ${msg}`;
            }
            console.log(msg);
        }
        this.errors.push({ resourceId, msg, critical });
    }
}
exports.DefaultContentsValidatorReports = DefaultContentsValidatorReports;
//# sourceMappingURL=validate-all-contents.js.map