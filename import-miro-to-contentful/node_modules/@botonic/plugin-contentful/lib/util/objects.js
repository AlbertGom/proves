"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.roughSizeOfObject = exports.deepClone = exports.shallowClone = void 0;
// eslint-disable-next-line @typescript-eslint/ban-types
function shallowClone(obj) {
    if (obj == undefined) {
        return obj;
    }
    //https://stackoverflow.com/a/28152032/145289 create copies the methods
    const clone = Object.create(obj);
    // without copying prototype, some fields (maybe the enums?) are not available in object
    // TODO try this let clone = Object.assign( Object.create( Object.getPrototypeOf(orig)), orig)
    // from https://stackoverflow.com/a/44782052/145289
    for (const prop in Object.getPrototypeOf(clone)) {
        clone[prop] = Object.getPrototypeOf(clone)[prop];
    }
    return clone;
}
exports.shallowClone = shallowClone;
/**
 * Deep copy function for TypeScript.
 * @param T Generic type of target/copied value.
 * @param target Target value to be copied.
 * @see Source project, ts-deepcopy https://github.com/ykdr2017/ts-deepcopy
 * @see Code pen https://codepen.io/erikvullings/pen/ejyBYg
 */
// eslint-disable-next-line @typescript-eslint/ban-types
const deepClone = (target, alreadyCloned = []) => {
    if (alreadyCloned.includes(target)) {
        return target;
    }
    alreadyCloned.push(target);
    if (target === undefined) {
        return target;
    }
    if (target instanceof Date) {
        return new Date(target.getTime());
    }
    if (target instanceof Array) {
        const cp = [];
        target.forEach(v => {
            cp.push(v);
        });
        return cp.map((n) => exports.deepClone(n, alreadyCloned));
    }
    if (typeof target === 'object' && target !== {}) {
        const cp = Object.assign({}, target);
        Object.keys(cp).forEach(k => {
            cp[k] = exports.deepClone(cp[k], alreadyCloned);
        });
        return cp;
    }
    return target;
};
exports.deepClone = deepClone;
/**
 * It returns a ROUGH estimation, since V8 will greatly optimize anyway
 * @return the number of bytes
 * Not using https://www.npmjs.com/package/object-sizeof to minimize dependencies
 */
function roughSizeOfObject(object) {
    const objectList = [];
    const recurse = function (value) {
        let bytes = 0;
        if (typeof value === 'boolean') {
            bytes = 4;
        }
        else if (typeof value === 'string') {
            bytes = value.length * 2;
        }
        else if (typeof value === 'number') {
            bytes = 8;
        }
        else if (value == null) {
            // Required because typeof null == 'object'
            bytes = 0;
        }
        else if (typeof value === 'object' && objectList.indexOf(value) === -1) {
            objectList.push(value);
            for (const [k, v] of Object.entries(value)) {
                bytes += 8; // an assumed existence overhead
                bytes += recurse(k);
                bytes += recurse(v);
            }
        }
        return bytes;
    };
    return recurse(object);
}
exports.roughSizeOfObject = roughSizeOfObject;
//# sourceMappingURL=objects.js.map