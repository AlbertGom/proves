export declare const NOT_FOUND_IN_CACHE: unique symbol;
export interface Cache<V> {
    set(id: string, val: V): void;
    get(id: string): V | typeof NOT_FOUND_IN_CACHE;
    has(id: string): boolean;
    del(id: string): void;
    /**
     * @return size in KB
     */
    size(): number;
    /**
     * Provides the Cache keys in undefined order 1 by 1
     * @param getMoreKeys will return true if the consumer of the keys wants another key
     */
    keys(): Generator<string>;
}
export declare class InMemoryCache<V> implements Cache<V> {
    private cache;
    private sizeBytes;
    set(id: string, val: V): void;
    del(id: string): void;
    get(id: string): V | typeof NOT_FOUND_IN_CACHE;
    has(id: string): boolean;
    size(): number;
    len(): number;
    keys(): Generator<string>;
}
/**
 * Decorates a cache by limiting its size.
 *
 * TODO Use an external library to have a LRU cache. However, it's not critical
 * because typically data in CMS is small (we're not caching media, only their
 * URLs)
 */
export declare class LimitedCacheDecorator<V> implements Cache<V> {
    private readonly cache;
    readonly limitKB: number;
    private readonly logger;
    readonly sizeWarningsRatio: number[];
    constructor(cache: Cache<V>, limitKB: number, logger?: (msg: string) => void, sizeWarningsRatio?: number[]);
    set(id: string, val: V): void;
    warnSizeRatio(incKB: number): void;
    get(id: string): V | typeof NOT_FOUND_IN_CACHE;
    has(id: string): boolean;
    del(id: string): void;
    keys(): Generator<string>;
    size(): number;
}
