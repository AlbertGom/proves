import { Cache } from './cache';
export declare type MemoizerNormalizer = (...args: any) => string;
export declare const jsonNormalizer: MemoizerNormalizer;
export declare type MemoizedFunction<Args extends any[], Return> = (...args: Args) => Promise<Return>;
export declare type MemoizerStrategy = <Args extends any[], Return>(cache: Cache<Return>, normalizer: typeof jsonNormalizer, func: (...args: Args) => Promise<Return>, ...args: Args) => Promise<Return>;
export interface MemoizerOptions {
    strategy: MemoizerStrategy;
    cacheFactory?: () => Cache<any>;
    normalizer?: MemoizerNormalizer;
}
export declare class Memoizer {
    opts: Required<MemoizerOptions>;
    constructor(opts: MemoizerOptions);
    memoize<Args extends any[], Return, F extends (...args: Args) => Promise<Return>>(func: F): F;
}
/***
 * Only re-invoke if not in cache
 */
export declare const cacheForeverStrategy: MemoizerStrategy;
/**
 * Always invokes the function, but fallbacks to last invocation result if available
 */
export declare function fallbackStrategy(usingFallback: (functName: string, args: any[], error: any) => Promise<void>): MemoizerStrategy;
