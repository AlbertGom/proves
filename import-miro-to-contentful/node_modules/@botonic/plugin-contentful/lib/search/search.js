"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Search = void 0;
const cms_1 = require("../cms");
const nlp_1 = require("../nlp");
const search_by_keywords_1 = require("./search-by-keywords");
class Search {
    constructor(cms, normalizer, keywordsOptions) {
        this.cms = cms;
        this.normalizer = normalizer;
        this.search = new search_by_keywords_1.SearchByKeywords(cms, normalizer, keywordsOptions);
    }
    /**
     * It does not sort the results based on the {@link SearchResult.priority}.
     * @param context must contain language
     */
    searchByKeywords(inputText, matchType, context, paging = new cms_1.PagingOptions()) {
        return __awaiter(this, void 0, void 0, function* () {
            const locale = nlp_1.checkLocale(context.locale);
            const utterance = this.normalizer.normalize(locale, inputText);
            const results = yield this.search.searchContentsFromInput(utterance, matchType, context, paging);
            return this.search.filterChitchat(utterance.words, results);
        });
    }
    respondFoundContents(results, confirmKeywordsFoundTextId, noKeywordsFoundTextId, context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (results.length == 0) {
                return this.cms.text(noKeywordsFoundTextId, context);
            }
            const chitchatCallback = results[0].getCallbackIfChitchat();
            if (chitchatCallback) {
                return this.cms.chitchat(chitchatCallback.id, context);
            }
            const buttonPromises = results.map((result) => __awaiter(this, void 0, void 0, function* () {
                if (result.contentId.model == cms_1.ContentType.URL) {
                    const url = yield this.cms.url(result.contentId.id, context);
                    return new cms_1.Button(result.common.id, result.common.name, result.common.shortText, cms_1.Callback.ofUrl(url.url));
                }
                return result.toButton();
            }));
            const buttons = yield Promise.all(buttonPromises);
            const text = yield this.cms.text(confirmKeywordsFoundTextId, context);
            return text.cloneWithButtons(buttons);
        });
    }
}
exports.Search = Search;
//# sourceMappingURL=search.js.map