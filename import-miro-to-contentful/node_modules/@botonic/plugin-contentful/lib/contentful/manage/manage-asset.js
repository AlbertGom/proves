"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManageContentfulAsset = void 0;
const cms_1 = require("../../cms");
class ManageContentfulAsset {
    constructor(options, manage, environment) {
        this.options = options;
        this.manage = manage;
        this.environment = environment;
    }
    removeAssetFile(context, assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            const environment = yield this.environment;
            const asset = yield environment.getAsset(assetId.id);
            delete asset.fields.file[context.locale];
            yield this.writeAsset(Object.assign(Object.assign({}, context), { allowOverwrites: true }), asset);
        });
    }
    copyAssetFile(context, assetId, fromLocale) {
        return __awaiter(this, void 0, void 0, function* () {
            const environment = yield this.environment;
            const oldAsset = yield environment.getAsset(assetId.id);
            if (!context.allowOverwrites && oldAsset.fields.file[context.locale]) {
                throw new Error(`Cannot overwrite asset '${assetId.toString()}' because it's not empty and ManageContext.allowOverwrites is false`);
            }
            const fromFile = oldAsset.fields.file[fromLocale];
            if (!fromFile) {
                throw Error(`Asset '${assetId.toString()}' has no file for locale ${fromLocale}`);
            }
            oldAsset.fields.file[context.locale] = fromFile;
            // we could use this.deliver.contentFromEntry & IgnoreFallbackDecorator to convert
            // the multilocale fields returned by update()
            yield this.writeAsset(context, oldAsset);
        });
    }
    removeAsset(context, assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            const environment = yield this.environment;
            try {
                const asset = yield environment.getAsset(assetId.id);
                if (asset.isPublished())
                    yield asset.unpublish();
                yield asset.delete();
            }
            catch (e) {
                throw new cms_1.CmsException('ERROR while deleting asset', e, assetId);
            }
        });
    }
    createAsset(context, file, info) {
        return __awaiter(this, void 0, void 0, function* () {
            const environment = yield this.environment;
            const data = {
                fields: {
                    title: {
                        [context.locale]: info.name,
                    },
                    description: {},
                    file: {
                        [context.locale]: {
                            contentType: info.type || '',
                            fileName: info.fileName || '',
                            file,
                        },
                    },
                },
            };
            if (info.description) {
                data.fields.description[context.locale] = info.description;
            }
            const asset = yield environment.createAssetFromFiles(data);
            const processedAsset = yield asset.processForLocale(context.locale);
            const publishedAsset = yield processedAsset.publish();
            return {
                id: publishedAsset.sys.id,
                url: publishedAsset.fields.file[context.locale].url,
            };
        });
    }
    writeAsset(context, asset) {
        return __awaiter(this, void 0, void 0, function* () {
            if (context.dryRun) {
                console.log('Not updating due to dryRun mode');
                return;
            }
            const updated = yield asset.update();
            if (!context.preview) {
                yield updated.publish();
            }
        });
    }
}
exports.ManageContentfulAsset = ManageContentfulAsset;
//# sourceMappingURL=manage-asset.js.map