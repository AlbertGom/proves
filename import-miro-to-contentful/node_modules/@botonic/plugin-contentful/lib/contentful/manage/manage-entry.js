"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManageContentfulEntry = void 0;
const cms_1 = require("../../cms");
const exceptions_1 = require("../../cms/exceptions");
const fields_1 = require("../../manage-cms/fields");
const enums_1 = require("../../util/enums");
const contentful_api_1 = require("./contentful-api");
class ManageContentfulEntry {
    constructor(options, manage, environment) {
        this.options = options;
        this.manage = manage;
        this.environment = environment;
    }
    updateFields(context, contentId, fields) {
        return __awaiter(this, void 0, void 0, function* () {
            const environment = yield this.environment;
            const oldEntry = yield this.getEntry(environment, contentId);
            let needUpdate = false;
            for (const key of Object.keys(fields)) {
                if (!enums_1.isOfType(key, fields_1.ContentFieldType)) {
                    throw new cms_1.CmsException(`'${key}' is not a valid content field type`);
                }
                const field = this.checkOverwrite(context, oldEntry, key, false);
                if (oldEntry.fields[field.cmsName][context.locale] === fields[key]) {
                    continue;
                }
                needUpdate = true;
                fields[key] = this.convertValueType(key, fields[key]);
                oldEntry.fields[field.cmsName][context.locale] = fields[key];
            }
            if (!needUpdate) {
                return oldEntry.fields;
            }
            // we could use this.deliver.contentFromEntry & IgnoreFallbackDecorator to convert
            // the multilocale fields returned by update()
            yield this.writeEntry(context, oldEntry);
            return oldEntry.fields;
        });
    }
    createContent(context, model, id) {
        return __awaiter(this, void 0, void 0, function* () {
            const environment = yield this.environment;
            try {
                yield environment.createEntryWithId(model, id, {
                    fields: {},
                });
            }
            catch (e) {
                throw new cms_1.CmsException(`ERROR while creating content with id: '${id}'`, e);
            }
        });
    }
    deleteContent(context, contentId) {
        return __awaiter(this, void 0, void 0, function* () {
            const environment = yield this.environment;
            try {
                const oldEntry = yield this.getEntry(environment, contentId);
                if (oldEntry.isPublished())
                    yield oldEntry.unpublish();
                yield oldEntry.delete();
            }
            catch (e) {
                throw new cms_1.CmsException('ERROR while deleting content', e);
            }
        });
    }
    checkOverwrite(context, entry, fieldType, failIfMissing) {
        if (entry.isArchived()) {
            throw new cms_1.CmsException(`Cannot update an archived entry`);
        }
        const field = fields_1.CONTENT_FIELDS.get(fieldType);
        if (!field) {
            throw new cms_1.CmsException(`Invalid field type '${fieldType}'`);
        }
        if (!context.locale) {
            // paranoic check
            throw new Error('Context.locale must be defined');
        }
        if (!(field.cmsName in entry.fields)) {
            if (!failIfMissing) {
                entry.fields[field.cmsName] = {};
                return field;
            }
            const fields = Object.keys(entry.fields);
            throw new cms_1.CmsException(`Field '${field.cmsName}' not found in entry of type '${entry.sys.contentType.sys.id}. It only has ${JSON.stringify(fields)}'`);
        }
        if (!context.allowOverwrites) {
            const value = entry.fields[field.cmsName][context.locale];
            if (value) {
                const error = `Cannot overwrite field '${field.cmsName}' of entry '${entry.sys.id}'`;
                const detail = `(has value '${String(value)}') because ManageContext.allowOverwrites is false`;
                throw new cms_1.CmsException(error + detail);
            }
        }
        return field;
    }
    copyField(context, contentId, fieldType, fromLocale, onlyIfTargetEmpty) {
        return __awaiter(this, void 0, void 0, function* () {
            const environment = yield this.environment;
            const oldEntry = yield environment.getEntry(contentId.id);
            const field = this.checkOverwrite(context, oldEntry, fieldType, false);
            const fieldEntry = oldEntry.fields[field.cmsName];
            if (fieldEntry === undefined) {
                return;
            }
            // TODO shouldn't this check be done before checkOverwrite?
            if (onlyIfTargetEmpty && context.locale in fieldEntry) {
                return;
            }
            fieldEntry[context.locale] = fieldEntry[fromLocale];
            yield this.writeEntry(context, oldEntry);
        });
    }
    writeEntry(context, entry) {
        return __awaiter(this, void 0, void 0, function* () {
            if (context.dryRun) {
                console.log('Not updating due to dryRun mode');
                return;
            }
            const updated = yield entry.update();
            if (!context.preview) {
                yield updated.publish();
            }
        });
    }
    getEntry(environment, contentId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield environment.getEntry(contentId.id);
            }
            catch (e) {
                throw new exceptions_1.ResourceNotFoundCmsException(contentId, e);
            }
        });
    }
    convertValueType(key, field) {
        var _a;
        const valueType = (_a = fields_1.CONTENT_FIELDS.get(key)) === null || _a === void 0 ? void 0 : _a.valueType;
        if (valueType === typeof field)
            return field;
        if (key === fields_1.ContentFieldType.BUTTONS_STYLE) {
            if (field === undefined)
                return null;
            return field === cms_1.ButtonStyle.QUICK_REPLY ? contentful_api_1.QUICK_REPLY : contentful_api_1.BUTTON;
        }
        if (field === undefined)
            return field;
        if (key === fields_1.ContentFieldType.FOLLOW_UP ||
            key === fields_1.ContentFieldType.TARGET ||
            key === fields_1.ContentFieldType.HANDOFF_QUEUE ||
            key === fields_1.ContentFieldType.ON_FINISH) {
            return this.getEntryLink(field, 'Entry');
        }
        if (key === fields_1.ContentFieldType.IMAGE || key === fields_1.ContentFieldType.PIC) {
            return this.getEntryLink(field, 'Asset');
        }
        if (key === fields_1.ContentFieldType.BUTTONS || key === fields_1.ContentFieldType.ELEMENTS) {
            const fieldLinks = field.map((id) => this.getEntryLink(id, 'Entry'));
            return fieldLinks;
        }
        return field;
    }
    getEntryLink(id, linkType) {
        return { sys: Object.assign({}, new contentful_api_1.EntryLink(id, linkType)) };
    }
}
exports.ManageContentfulEntry = ManageContentfulEntry;
//# sourceMappingURL=manage-entry.js.map