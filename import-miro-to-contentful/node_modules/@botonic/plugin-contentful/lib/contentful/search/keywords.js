"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeywordsDelivery = void 0;
const cms_1 = require("../../cms");
const search_1 = require("../../search");
const delivery_utils_1 = require("../delivery-utils");
class KeywordsDelivery {
    constructor(delivery) {
        this.delivery = delivery;
    }
    contentsWithKeywords(context, paging, modelsWithKeywords = [
        cms_1.ContentType.TEXT,
        cms_1.ContentType.CAROUSEL,
        cms_1.ContentType.URL,
    ], modelsWithSearchableByKeywords = [cms_1.ContentType.QUEUE]) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO maybe it's more efficient to get all contents (since most have keywords anyway and we normally have few non
            //  TopContents such as Buttons)
            const fromKeywords = this.entriesWithKeywords(context, modelsWithKeywords, paging);
            const fromSearchable = this.entriesWithSearchableByKeywords(context, modelsWithSearchableByKeywords);
            return (yield fromKeywords).concat(yield fromSearchable);
        });
    }
    static candidateFromEntry(entry, keywords, priority) {
        const contentModel = delivery_utils_1.ContentfulEntryUtils.getContentModel(entry);
        if (!entry.fields.shortText) {
            console.error(`No shortText found for content of type ${contentModel} and name: ${entry.fields.name}`);
            entry.fields.shortText = entry.fields.name;
        }
        const contentId = new cms_1.TopContentId(contentModel, entry.sys.id);
        return new search_1.SearchCandidate(contentId, new cms_1.CommonFields(contentId.id, entry.fields.name, {
            shortText: entry.fields.shortText,
            keywords,
        }), priority);
    }
    entriesWithSearchableByKeywords(context, models) {
        return __awaiter(this, void 0, void 0, function* () {
            const getWithKeywords = (contentType) => this.delivery.getEntries(context, {
                // eslint-disable-next-line @typescript-eslint/naming-convention
                content_type: contentType,
                'fields.searchableBy[exists]': true,
                include: 1,
            });
            const promises = [];
            for (const contentType of models) {
                promises.push(getWithKeywords(contentType));
            }
            const queues = yield Promise.all(promises);
            const results = [];
            for (const q of queues) {
                for (const queueFields of q.items) {
                    for (const result of KeywordsDelivery.candidatesFromQueue(queueFields)) {
                        results.push(result);
                    }
                }
            }
            return results;
        });
    }
    static candidatesFromQueue(queue) {
        return queue.fields.searchableBy.map(searchable => this.candidateFromEntry(queue, searchable.fields.keywords, searchable.fields.priority));
    }
    entriesWithKeywords(context, models, paging) {
        const getWithKeywords = (contentType) => this.delivery.getEntries(context, Object.assign(Object.assign({}, paging), { 
            // eslint-disable-next-line @typescript-eslint/naming-convention
            content_type: contentType, 'fields.keywords[exists]': true, include: 0 }));
        const promises = [];
        for (const contentType of models) {
            promises.push(getWithKeywords(contentType));
        }
        return Promise.all(promises).then(entryCollections => KeywordsDelivery.flatMapEntryCollection(entryCollections).map(entry => KeywordsDelivery.candidateFromEntry(entry, entry.fields.keywords || [])));
    }
    static flatMapEntryCollection(collections) {
        const entries = [];
        collections.forEach(collection => entries.push(...collection.items));
        return entries;
    }
}
exports.KeywordsDelivery = KeywordsDelivery;
//# sourceMappingURL=keywords.js.map