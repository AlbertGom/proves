"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addCustomFields = exports.convertContentfulException = exports.createContentfulClientApi = exports.ContentfulEntryUtils = void 0;
const contentful = __importStar(require("contentful"));
const cms_1 = require("../cms");
const exceptions_1 = require("../cms/exceptions");
const time = __importStar(require("../time"));
const searchable_by_1 = require("./search/searchable-by");
class ContentfulEntryUtils {
    static getContentId(entry) {
        return new cms_1.ContentId(ContentfulEntryUtils.getContentModel(entry), entry.sys.id);
    }
    /**
     * Will be false for broken references, or when we have only fetched
     * the full Entry tree
     */
    static isFullEntry(entry) {
        return !!entry.fields;
    }
    static getContentModel(entry) {
        // https://blog.oio.de/2014/02/28/typescript-accessing-enum-values-via-a-string/
        if (!entry.sys.contentType) {
            throw new cms_1.CmsException(`Entry '${entry.sys.id}' not fully loaded or referencing a deleted content`);
        }
        const typ = entry.sys.contentType.sys.id;
        return typ;
    }
    static commonFieldsFromEntry(entry, followUp) {
        const fields = entry.fields;
        const searchableBy = fields.searchableBy &&
            new cms_1.SearchableBy(fields.searchableBy.map(searchableBy => searchable_by_1.SearchableByKeywordsDelivery.fromEntry(searchableBy)));
        const dateRange = fields.dateRange &&
            ContentfulEntryUtils.fromDateRangeEntry(fields.dateRange);
        return new cms_1.CommonFields(entry.sys.id, fields.name || '', {
            keywords: fields.keywords,
            shortText: fields.shortText,
            partitions: fields.partitions,
            searchableBy,
            dateRange,
            followUp,
            //customFields cannot be easily told apart from standard fields until the content is created. see addCustomFields
        });
    }
    /** Cannot be in date-range to avoid circular dependency */
    static fromDateRangeEntry(entry) {
        const dateRange = new time.DateRange(entry.fields.name, new Date(Date.parse(entry.fields.from)), new Date(Date.parse(entry.fields.to)));
        return new cms_1.DateRangeContent(ContentfulEntryUtils.commonFieldsFromEntry(entry), dateRange);
    }
}
exports.ContentfulEntryUtils = ContentfulEntryUtils;
function createContentfulClientApi(options) {
    const params = {
        space: options.spaceId,
        accessToken: options.accessToken,
        timeout: options.timeoutMs,
    };
    if (options.environment) {
        params.environment = options.environment;
    }
    const client = contentful.createClient(params);
    return client;
}
exports.createContentfulClientApi = createContentfulClientApi;
function convertContentfulException(e, query) {
    var _a;
    const errors = (_a = e === null || e === void 0 ? void 0 : e.details) === null || _a === void 0 ? void 0 : _a.errors;
    if (Array.isArray(errors) &&
        errors.length &&
        errors[0].name === 'unknownContentType') {
        return new exceptions_1.ResourceTypeNotFoundCmsException(query['content_type'] || 'not set', e);
    }
    return e;
}
exports.convertContentfulException = convertContentfulException;
//supported types: string, number and boolean
function addCustomFields(content, entryFields, ignoreFields) {
    const customKeys = Object.keys(entryFields).filter(f => !Object.keys(content).includes(f) &&
        !Object.keys(content.common).includes(f) &&
        !(ignoreFields === null || ignoreFields === void 0 ? void 0 : ignoreFields.includes(f)) &&
        //contentful: followup, plugin: followUp
        'followup' != f);
    for (const customKey of customKeys) {
        content.common.customFields[customKey] = entryFields[customKey];
    }
    return content;
}
exports.addCustomFields = addCustomFields;
//# sourceMappingURL=delivery-utils.js.map