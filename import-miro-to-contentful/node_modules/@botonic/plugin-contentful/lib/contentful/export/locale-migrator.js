"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocaleRemover = exports.LocaleMigrator = void 0;
const assert_1 = __importDefault(require("assert"));
/**
 * Useful to clone the contents flow from a space when the target locales are different.
 */
class LocaleMigrator {
    /**
     * @param fromLoc The locale whose flow we want to maintain
     * @param toLoc The locale in which `fromLoc`'s flow will be converted
     */
    constructor(fromLoc, toLoc, verbose = false) {
        this.fromLoc = fromLoc;
        this.toLoc = toLoc;
        this.verbose = verbose;
    }
    getDefaultLocale(spaceExport) {
        if (spaceExport.payload.locales) {
            const fromLoc = spaceExport.getLocale(this.fromLoc);
            if (fromLoc && fromLoc.fallbackCode) {
                return fromLoc.fallbackCode;
            }
            const defaultLoc = spaceExport.getDefaultLocale();
            if (defaultLoc) {
                return defaultLoc.code;
            }
        }
        console.log(`I don't know fallback for ${this.fromLoc}. Assuming any available locale`);
        return undefined;
    }
    migrate(spaceExport) {
        if (this.fromLoc == this.toLoc) {
            console.warn('Source and target locale are the same');
            return;
        }
        this.defaultLoc = this.getDefaultLocale(spaceExport);
        this.migrateAssets(spaceExport);
        this.migrateEntries(spaceExport);
        this.migrateLocales(spaceExport);
    }
    migrateEntries(spaceExport) {
        for (const entry of spaceExport.payload.entries) {
            for (const fieldName of Object.getOwnPropertyNames(entry.fields)) {
                try {
                    const vals = entry.fields[fieldName];
                    if (this.verbose) {
                        console.log(`Migrating entry ${entry.sys.id}.${fieldName}`);
                    }
                    this.migrateField(vals);
                }
                catch (e) {
                    const cause = e;
                    throw Error(`converting entry ${entry.sys.id} field '${fieldName}': ${cause.toString()}`);
                }
            }
        }
    }
    migrateAssets(spaceExport) {
        if (!spaceExport.payload.assets) {
            return;
        }
        for (const asset of spaceExport.payload.assets) {
            for (const fieldName of Object.getOwnPropertyNames(asset.fields)) {
                try {
                    const vals = asset.fields[fieldName];
                    if (this.verbose) {
                        console.log(`Migrating asset ${asset.sys.id}.${fieldName}`);
                    }
                    this.migrateField(vals);
                }
                catch (e) {
                    const cause = e;
                    throw Error(`converting asset ${asset.sys.id} field '${fieldName}': ${cause.toString()}`);
                }
            }
        }
    }
    migrateField(values) {
        let value = values[this.fromLoc];
        if (!value) {
            // TODO also get it if language being removed
            if (this.defaultLoc && this.defaultLoc == this.fromLoc) {
                value = values[this.defaultLoc];
            }
        }
        if (!(this.toLoc in values)) {
            values[this.toLoc] = value;
        }
        delete values[this.fromLoc];
    }
    migrateLocales(spaceExport) {
        let locales = spaceExport.payload.locales;
        if (locales) {
            const fromLoc = spaceExport.getLocale(this.fromLoc);
            assert_1.default(fromLoc);
            const toLoc = spaceExport.getLocale(this.toLoc);
            if (toLoc) {
                locales = locales.filter(loc => loc.code != this.fromLoc);
                if (fromLoc.fallbackCode == toLoc.fallbackCode) {
                    // @ts-ignore a bug fallbackCode type?
                    toLoc.fallbackCode = null;
                    console.log('Removing fallback');
                }
                if (fromLoc.default) {
                    console.log(`Setting '${toLoc.code}' as default locale`);
                    toLoc.default = true;
                    // @ts-ignore
                    toLoc.fallbackCode = null;
                }
            }
            else {
                fromLoc.code = this.toLoc;
                fromLoc.name = this.toLoc;
            }
            spaceExport.payload.locales = locales;
        }
    }
}
exports.LocaleMigrator = LocaleMigrator;
class LocaleRemover {
    /**
     * @param removeLocs The locales to completely remove
     */
    constructor(removeLocs, newDefault) {
        this.removeLocs = removeLocs;
        this.newDefault = newDefault;
    }
    remove(spaceExport) {
        this.removeEntries(spaceExport);
        this.removeAssets(spaceExport);
        this.removeLocales(spaceExport);
    }
    removeEntries(spaceExport) {
        const defaultLoc = spaceExport.getDefaultLocale();
        for (const entry of spaceExport.payload.entries) {
            for (const fieldName of Object.getOwnPropertyNames(entry.fields)) {
                const vals = entry.fields[fieldName];
                this.removeField(vals, defaultLoc);
            }
        }
    }
    removeAssets(spaceExport) {
        if (!spaceExport.payload.assets) {
            return;
        }
        const defaultLoc = spaceExport.getDefaultLocale();
        for (const assets of spaceExport.payload.assets) {
            for (const fieldName of Object.getOwnPropertyNames(assets.fields)) {
                const vals = assets.fields[fieldName];
                this.removeField(vals, defaultLoc);
            }
        }
    }
    removeField(vals, defaultLoc) {
        for (const loc of this.removeLocs) {
            if (this.newDefault &&
                vals[this.newDefault] == undefined &&
                vals[loc] != undefined &&
                (defaultLoc === null || defaultLoc === void 0 ? void 0 : defaultLoc.code) == loc) {
                vals[this.newDefault] = vals[loc];
            }
            delete vals[loc];
        }
    }
    removeLocales(spaceExport) {
        if (!spaceExport.payload.locales) {
            return;
        }
        for (const removeLoc of this.removeLocs) {
            if (!spaceExport.getLocale(removeLoc)) {
                console.error(`Expecting to remove locale ${removeLoc} but not found`);
                continue;
            }
            for (const loc of spaceExport.payload.locales) {
                if (this.removeLocs.includes(loc.code)) {
                    continue;
                }
                if (loc.fallbackCode == removeLoc) {
                    console.log(`Fallback for ${loc.code} is now invalid. Please edit it`);
                }
            }
        }
        spaceExport.payload.locales = spaceExport.payload.locales.filter(loc => !this.removeLocs.includes(loc.code));
        for (const loc of spaceExport.payload.locales) {
            if (this.newDefault && loc.code == this.newDefault) {
                loc.default = true;
                // @ts-ignore
                loc.fallbackCode = null;
                loc.optional = false;
            }
        }
    }
}
exports.LocaleRemover = LocaleRemover;
//# sourceMappingURL=locale-migrator.js.map