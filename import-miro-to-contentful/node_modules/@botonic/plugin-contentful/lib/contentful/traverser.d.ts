import * as cf from 'contentful';
import { Context, ContextWithLocale } from '../cms';
import { Locale } from '../nlp';
import { DeliveryApi } from './delivery-api';
export declare type I18nValue<T> = {
    [locale: string]: T;
};
export declare class VisitedField<V> {
    readonly entry: cf.Entry<any>;
    readonly locale: Locale;
    readonly field: cf.Field;
    readonly value: I18nValue<V>;
    constructor(entry: cf.Entry<any>, locale: Locale, field: cf.Field, value: I18nValue<V>);
}
export interface ContentfulVisitor {
    name(): string;
    visitEntry<T>(entry: cf.Entry<T>): cf.Entry<T>;
    visitStringField(field: VisitedField<string>): I18nValue<string>;
    visitOtherField(vf: VisitedField<any>): I18nValue<any>;
    visitMultipleStringField(field: VisitedField<string[]>): I18nValue<string[]>;
    visitSingleReference(field: VisitedField<cf.Entry<any>>): I18nValue<cf.Entry<any>>;
    visitMultipleReference<T>(field: VisitedField<cf.EntryCollection<T>>): I18nValue<cf.EntryCollection<T>>;
}
export declare class LoggerContentfulVisitor implements ContentfulVisitor {
    private readonly visitor;
    constructor(visitor: ContentfulVisitor);
    name(): string;
    visitEntry<T>(entry: cf.Entry<T>): cf.Entry<T>;
    visitStringField<T>(field: VisitedField<string>): I18nValue<string>;
    visitMultipleStringField<T>(field: VisitedField<string[]>): I18nValue<string[]>;
    visitOtherField(field: VisitedField<any>): I18nValue<any>;
    visitSingleReference<T>(field: VisitedField<cf.Entry<T>>): I18nValue<cf.Entry<T>>;
    visitMultipleReference<T>(field: VisitedField<cf.EntryCollection<T>>): I18nValue<cf.EntryCollection<T>>;
    log<V>(method: string, entry: cf.Entry<any>, field?: cf.Field): void;
    static describeEntry(entry: cf.Entry<any>): string;
    static describeField(entry: cf.Entry<any>, name: string): string;
}
/**
 * Traverser a contentful Entry which has been requested for all locales.
 * Limitations. It does not fetch entries from references which have not yet been delivered.
 * ATTENTION Due to the complexity of traversing links with potential circular references, it stops recursion on button
 * callbacks. This causes some entries to get wrong values.
 */
export declare class I18nEntryTraverser {
    private readonly api;
    readonly visitor: ContentfulVisitor;
    private visited;
    constructor(api: DeliveryApi, visitor: ContentfulVisitor);
    traverse<T>(entry: cf.Entry<T>, context: Context): Promise<cf.Entry<T>>;
    traverseCore<T>(entry: cf.Entry<T>, context: ContextWithLocale): Promise<cf.Entry<T>>;
    traverseField<E>(context: ContextWithLocale, vf: VisitedField<any>): Promise<I18nValue<any>>;
    isArrayOfType(field: cf.Field, itemType: cf.FieldType): boolean;
    /**
     * When a content has a button with another content reference, we just need the referred content id
     * to create the content. Hence, we stop traversing.
     */
    private stopRecursionOnButtonCallbacks;
}
