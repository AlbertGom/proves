"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentfulExceptionWrapper = exports.ErrorReportingCMS = void 0;
/* eslint-disable @typescript-eslint/unbound-method */
const async_parallel_1 = require("async-parallel");
const util_1 = require("../util");
const async_1 = require("../util/async");
const callback_1 = require("./callback");
const cms_1 = require("./cms");
const context_1 = require("./context");
const exceptions_1 = require("./exceptions");
/**
 * It validates the individually delivered contents, but not those fetched
 * through contents/topContents
 */
class ErrorReportingCMS {
    constructor(cms, logger) {
        this.cms = cms;
        this.logger = logger;
        this.exceptionWrapper = new ContentfulExceptionWrapper('CMS', logger);
    }
    validate(content, context) {
        const validation = content.validate();
        if (validation) {
            const locale = (context === null || context === void 0 ? void 0 : context.locale) ? ` on locale '${context.locale}'` : '';
            const msg = `${content.contentType} ${content.toString()}${locale}: ${validation}`;
            if (this.logger)
                this.logger(msg);
            else
                console.error(msg);
        }
        return content;
    }
    catchAndValidate(id, context, contentType, promise) {
        return __awaiter(this, void 0, void 0, function* () {
            const m = new util_1.Measure('cms.' + contentType);
            try {
                const c = yield promise;
                m.end();
                this.validate(c, context);
                return c;
            }
            catch (e) {
                this.handleContentError(contentType, id, context)(e);
                throw new Error('should not reach here');
            }
        });
    }
    carousel(id, context) {
        return this.catchAndValidate(id, context, cms_1.ContentType.CAROUSEL, this.cms.carousel(id, context));
    }
    document(id, context) {
        return this.catchAndValidate(id, context, cms_1.ContentType.DOCUMENT, this.cms.document(id, context));
    }
    handoff(id, context) {
        return this.catchAndValidate(id, context, cms_1.ContentType.HANDOFF, this.cms.handoff(id, context));
    }
    custom(id, context) {
        return this.catchAndValidate(id, context, cms_1.CustomContentType.CUSTOM, this.cms.custom(id, context));
    }
    text(id, context) {
        return this.catchAndValidate(id, context, cms_1.ContentType.TEXT, this.cms.text(id, context));
    }
    chitchat(id, context) {
        return this.catchAndValidate(id, context, cms_1.ContentType.CHITCHAT, this.cms.chitchat(id, context));
    }
    startUp(id, context) {
        return this.catchAndValidate(id, context, cms_1.ContentType.STARTUP, this.cms.startUp(id, context));
    }
    url(id, context) {
        return this.catchAndValidate(id, context, cms_1.ContentType.URL, this.cms.url(id, context));
    }
    payload(id, context) {
        return this.catchAndValidate(id, context, cms_1.ContentType.PAYLOAD, this.cms.payload(id, context));
    }
    image(id, context) {
        return this.catchAndValidate(id, context, cms_1.ContentType.IMAGE, this.cms.image(id, context));
    }
    queue(id, context) {
        return this.catchAndValidate(id, context, cms_1.ContentType.QUEUE, this.cms.queue(id, context));
    }
    button(id, context) {
        return this.catchAndValidate(id, context, cms_1.ContentType.BUTTON, this.cms.button(id, context));
    }
    element(id, context) {
        return this.catchAndValidate(id, context, cms_1.ContentType.ELEMENT, this.cms.element(id, context));
    }
    contentsWithKeywords(context, paging) {
        return this.cms
            .contentsWithKeywords(context, paging)
            .catch(this.handleError('contentsWithKeywords', {}, context));
    }
    topContents(model, context, filter, paging) {
        return __awaiter(this, void 0, void 0, function* () {
            const m = new util_1.Measure('topContents.' + model);
            const contents = yield this.cms
                .topContents(model, context, filter, paging)
                .catch(this.handleError('topContents', { model }, context));
            m.end();
            return contents;
        });
    }
    content(id, context = context_1.DEFAULT_CONTEXT) {
        return this.cms
            .content(id, context)
            .catch(this.handleContentError('content', id, context));
    }
    contents(model, context, paging) {
        return this.cms
            .contents(model, context, paging)
            .catch(this.handleError('contents', { model }, context));
    }
    assets(context) {
        return this.cms
            .assets(context)
            .catch(this.handleError('assets', {}, context));
    }
    schedule(id, context) {
        return this.cms
            .schedule(id, context)
            .catch(this.handleContentError(cms_1.ContentType.SCHEDULE, id, context));
    }
    dateRange(id, context) {
        return this.cms
            .dateRange(id, context)
            .catch(this.handleContentError(cms_1.ContentType.DATE_RANGE, id, context));
    }
    asset(id, context) {
        return this.cms
            .asset(id, context)
            .catch(this.handleResourceError(new callback_1.AssetId(id, undefined), context));
    }
    handleContentError(contentType, id, context) {
        return this.handleResourceError(callback_1.ContentId.create(contentType, id), context);
    }
    handleResourceError(resourceId, context) {
        return (reason) => {
            throw this.exceptionWrapper.wrap(reason, resourceId.resourceType, resourceId, {}, context);
        };
    }
    handleError(method, args, context) {
        return (reason) => {
            throw this.exceptionWrapper.wrap(reason, method, undefined, args, context);
        };
    }
}
exports.ErrorReportingCMS = ErrorReportingCMS;
class ContentfulExceptionWrapper {
    constructor(wrappee, logger = (msg) => {
        console.error(msg);
    }) {
        this.wrappee = wrappee;
        this.logger = logger;
        // TODO add logStack in plugin config
        this.logStack = true;
    }
    wrap(contentfulError, method, resourceId, args, context) {
        let content = '';
        if (context === null || context === void 0 ? void 0 : context.locale) {
            content += ` with locale '${context.locale}'`;
        }
        if (resourceId) {
            content += ` on ${resourceId.toString()}`;
        }
        if (Object.keys(args).length) {
            content += ` with args '${JSON.stringify(args)}'`;
        }
        const msg = `Error calling ${this.wrappee}.${method}${content}`;
        const exception = new exceptions_1.CmsException(msg, contentfulError, resourceId);
        const err = this.processError(contentfulError);
        this.logger(`${msg} Due to ${err}`);
        throw exception;
    }
    processError(contentfulError) {
        let err = '';
        if (contentfulError instanceof async_parallel_1.MultiError) {
            err += ' Due to:';
            for (const e of async_1.reduceMultiError(contentfulError)) {
                err += this.processError(e);
            }
        }
        else if (this.logStack && contentfulError.stack) {
            err += contentfulError.stack.split('\n').slice(0, 5).join('\n');
        }
        else {
            err += `Due to '${contentfulError.message}'`;
        }
        return err;
    }
}
exports.ContentfulExceptionWrapper = ContentfulExceptionWrapper;
//# sourceMappingURL=cms-error.js.map