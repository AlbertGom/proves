import * as time from '../time';
import { Stringable } from '../util/objects';
import { Callback, ContentId, TopContentId } from './callback';
import { ContentType, MessageContentType, TopContentType } from './cms';
import { SearchableBy } from './fields';
export declare enum ButtonStyle {
    BUTTON = 0,
    QUICK_REPLY = 1
}
/**
 * @param type eg. image/jpeg
 */
export interface AssetInfo {
    readonly name: string;
    readonly fileName?: string;
    readonly type?: string;
    readonly description?: string;
}
/** Not a Content because it cannot have custom fields */
export declare class Asset {
    readonly id: string;
    readonly url: string;
    readonly info: AssetInfo;
    readonly details?: any;
    /**
     * @param details depends on the type. eg the image size
     */
    constructor(id: string, url: string, info: AssetInfo, details?: any);
}
/**
 * Any content deliverable from a CMS.
 * They are immutable, which allows sharing and caching them.
 */
export declare abstract class Content implements Stringable {
    readonly contentType: ContentType;
    protected constructor(contentType: ContentType);
    /** @return error message if any issue detected */
    validate(): string | undefined;
    abstract get id(): string;
    abstract get name(): string;
    get contentId(): ContentId;
    toString(): string;
    static validateContents(contents: Content[]): string | undefined;
    static mergeValidations(validations: (string | undefined)[]): string | undefined;
}
/**
 * A self-contained content with {@link CommonFields}
 */
export declare abstract class TopContent extends Content {
    readonly common: CommonFields;
    readonly contentType: TopContentType;
    protected constructor(common: CommonFields, contentType: TopContentType);
    get name(): string;
    get id(): string;
    get contentId(): TopContentId;
    isSearchable(): boolean;
}
/**
 * Contents which have a correspondent Botonic React Message
 */
export declare abstract class MessageContent extends TopContent {
    readonly common: CommonFields;
    readonly contentType: MessageContentType;
    protected constructor(common: CommonFields, contentType: MessageContentType);
    findRecursively(predicate: (c: MessageContent) => boolean): MessageContent | undefined;
    cloneWithFollowUp(newFollowUp: FollowUp | undefined): this;
    cloneWithFollowUpLast(lastContent: FollowUp): this;
    validate(): string | undefined;
}
/**
 * When any {@link keywords} is detected on a user input, we can use display the {@link shortText} for users
 * to confirm their interest on this content
 */
export declare class CommonFields implements Stringable {
    readonly id: string;
    readonly name: string;
    readonly shortText: string;
    readonly keywords: string[];
    readonly searchableBy?: SearchableBy;
    /** Useful when contents need to be replicated according to some criteria. Eg. country, company,...
     */
    readonly partitions: string[];
    readonly dateRange?: DateRangeContent;
    readonly followUp?: FollowUp;
    readonly customFields: Record<string, unknown>;
    constructor(id: string, name: string, opt?: {
        shortText?: string;
        keywords?: string[];
        searchableBy?: SearchableBy;
        partitions?: string[];
        dateRange?: DateRangeContent;
        followUp?: FollowUp;
        customFields?: Record<string, unknown>;
    });
    toString(): string;
}
/**
 * In CMS, there are 2 options to store the buttons:
 * 1) To have direct references to the target content opened by the button
 * 2) To have intermediate button contents which reference
 * the target and allow the button to have a text different than the target content's
 * shortText.
 *
 * Option 1 has these advantages:
 * - The contents also needs the shortText to display a button to disambiguate when
 * the bot does NLU based on the content keywords.
 * - It simplifies adding and removing a button (it's only a link to another content)
 * - It avoids duplication of texts (specially for targets with many sources and many languages)
 * - It simplifies the i18n (the text of the button is more related to the target content that to the source one)
 */
export declare class Button extends Content {
    readonly id: string;
    readonly name: string;
    readonly callback: Callback;
    private readonly usingNameForText;
    readonly text: string;
    /**
     * @param id If content having the button has a direct reference to the target
     * content instead of a Button content, the id will be the id of the target.
     * If content having the button has a reference to a Button content, id will
     * be the id of the Button content
     */
    constructor(id: string, name: string, text: string, callback: Callback);
    validate(): string | undefined;
    isDirectReferenceToTarget(): boolean;
    toString(): string;
    cloneWithText(newText: string): this;
}
export declare type CustomFields = Record<string, any>;
export declare class Custom extends Content {
    readonly id: string;
    readonly name: string;
    readonly fields: CustomFields;
    constructor(id: string, name: string, fields?: CustomFields);
}
export declare class StartUp extends MessageContent {
    readonly common: CommonFields;
    readonly imgUrl: string | undefined;
    readonly text: string;
    readonly buttons: Button[];
    constructor(common: CommonFields, imgUrl: string | undefined, text: string, buttons: Button[]);
    validate(): string | undefined;
    cloneWithText(newText: string): this;
    cloneWithButtons(buttons: Button[]): this;
}
export declare class Carousel extends MessageContent {
    readonly common: CommonFields;
    readonly elements: Element[];
    constructor(common: CommonFields, elements?: Element[]);
    validate(): string | undefined;
    cloneWithElements(elements: Element[]): this;
}
/** Part of a carousel */
export declare class Element extends Content {
    readonly id: string;
    readonly buttons: Button[];
    readonly title: string;
    readonly subtitle: string;
    readonly imgUrl: string;
    readonly name: string;
    constructor(id: string, buttons: Button[], title: string, subtitle?: string, imgUrl?: string);
    validate(): string | undefined;
    cloneWithButtons(buttons: Button[]): this;
}
export declare class Document extends MessageContent {
    readonly common: CommonFields;
    readonly docUrl: string;
    constructor(common: CommonFields, docUrl: string);
}
export declare class Image extends MessageContent {
    readonly common: CommonFields;
    readonly imgUrl: string;
    constructor(common: CommonFields, imgUrl: string);
}
export declare class Text extends MessageContent {
    readonly common: CommonFields;
    readonly text: string;
    readonly buttons: Button[];
    readonly buttonsStyle?: ButtonStyle | undefined;
    constructor(common: CommonFields, text: string, buttons: Button[], buttonsStyle?: ButtonStyle | undefined);
    validate(): string | undefined;
    cloneWithButtons(buttons: Button[]): this;
    cloneWithText(newText: string): this;
}
export declare type Chitchat = Text;
export declare const Chitchat: typeof Text;
export declare class Url extends TopContent {
    readonly common: CommonFields;
    readonly url: string;
    constructor(common: CommonFields, url: string);
}
export declare class Payload extends TopContent {
    readonly common: CommonFields;
    readonly payload: string;
    constructor(common: CommonFields, payload: string);
}
export declare class Queue extends TopContent {
    readonly common: CommonFields;
    readonly queue: string;
    readonly schedule?: time.Schedule | undefined;
    readonly handoffMessage?: string | undefined;
    constructor(common: CommonFields, queue: string, schedule?: time.Schedule | undefined, handoffMessage?: string | undefined);
}
export declare class DateRangeContent extends TopContent {
    readonly common: CommonFields;
    readonly dateRange: time.DateRange;
    constructor(common: CommonFields, dateRange: time.DateRange);
}
export declare class ScheduleContent extends TopContent {
    readonly common: CommonFields;
    readonly schedule: time.Schedule;
    constructor(common: CommonFields, schedule: time.Schedule);
}
export declare type OnFinish = Callback;
export declare class HandoffAgentEmail {
    readonly agentEmail: string;
    readonly type = "AGENT_EMAIL";
    constructor(agentEmail: string);
}
export declare class HandoffAgentId {
    readonly agentId: string;
    readonly type = "AGENT_ID";
    constructor(agentId: string);
}
export declare type HandoffAgent = HandoffAgentEmail | HandoffAgentId;
/**
 * Most CommonFields make no sense for Handoff.
 * However, we decided to make it a TopContent since it does not depend on other content.
 * Also CommonFields might be potentially useful.
 */
export declare class Handoff extends TopContent {
    readonly common: CommonFields;
    readonly onFinish: OnFinish;
    readonly message?: string | undefined;
    readonly failMessage?: string | undefined;
    readonly queue?: Queue | undefined;
    readonly agent?: HandoffAgent | undefined;
    readonly shadowing?: boolean | undefined;
    constructor(common: CommonFields, onFinish: OnFinish, message?: string | undefined, failMessage?: string | undefined, queue?: Queue | undefined, agent?: HandoffAgent | undefined, shadowing?: boolean | undefined);
    cloneWithQueue(newQueue: Queue): this;
    cloneWithAgent(newAgent: HandoffAgent): this;
}
/**
 * A {@link Content} which is automatically displayed after another one
 */
export declare type FollowUp = MessageContent;
