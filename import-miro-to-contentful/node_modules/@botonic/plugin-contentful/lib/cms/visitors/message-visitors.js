"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.allMessageContents = exports.allTopContents = exports.allContents = exports.MessageContentInverseTraverser = exports.reachableFrom = exports.MessageContentTraverser = exports.getButtons = void 0;
const arrays_1 = require("../../util/arrays");
const async_1 = require("../../util/async");
const __1 = require("../");
const contents_1 = require("../contents");
function getButtons(content) {
    if (content instanceof contents_1.Carousel) {
        return Array.prototype.concat(...content.elements.map(e => e.buttons));
    }
    if (content instanceof contents_1.Text || content instanceof contents_1.StartUp) {
        return content.buttons;
    }
    return [];
}
exports.getButtons = getButtons;
/**
 * Goes through a content's buttons and followups
 * TODO add cache
 */
class MessageContentTraverser {
    /**
     * It does not take care of circular loops
     */
    constructor(cms, visitor, options = {}) {
        this.cms = cms;
        this.visitor = visitor;
        this.options = Object.assign({ depth: 1, ignoreButtons: false, ignoreFollowUps: false }, options);
        if (this.options.depth > 1) {
            throw new __1.CmsException('Depth>1 not supported yet for MessageContentTraverser');
        }
    }
    traverse(content, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const promises = [];
            if (!this.options.ignoreButtons) {
                promises.push(this.traverseButtons(content, context));
            }
            if (!this.options.ignoreFollowUps) {
                this.traverseFollowUps(content);
            }
            yield Promise.all(promises);
        });
    }
    traverseButtons(content, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const buttons = getButtons(content);
            for (const button of buttons) {
                const contentId = button.callback.asContentId();
                if (contentId) {
                    const reference = (yield contentId.deliver(this.cms, context));
                    this.visitor(reference);
                }
            }
        });
    }
    traverseFollowUps(content) {
        var _a;
        while ((_a = content.common) === null || _a === void 0 ? void 0 : _a.followUp) {
            this.visitor(content.common.followUp);
            content = content.common.followUp;
        }
    }
}
exports.MessageContentTraverser = MessageContentTraverser;
function reachableFrom(cms, fromContents, context, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const reachable = new Set();
        const visitor = (content) => {
            reachable.add(content);
        };
        const traverser = new MessageContentTraverser(cms, visitor, options);
        yield async_1.asyncEach(context, fromContents, fromContent => traverser.traverse(fromContent, context));
        return reachable;
    });
}
exports.reachableFrom = reachableFrom;
/**
 * To obtain which contents have references (eg. buttons) to a given
 * content
 */
class MessageContentInverseTraverser {
    constructor(cms, info, context, options = {}) {
        this.cms = cms;
        this.info = info;
        this.context = context;
        this.options = options;
        this.referencesTo = new Map();
        if (options.depth && options.depth > 1) {
            throw new __1.CmsException('Depth>1 not supported yet for MessageContentInverseTraverser');
        }
    }
    isLoaded() {
        return this.referencesTo.size > 0;
    }
    messageContentTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            return arrays_1.andArrays(__1.MESSAGE_CONTENT_TYPES, yield this.info.contentTypes());
        });
    }
    load(fromContents) {
        return __awaiter(this, void 0, void 0, function* () {
            fromContents =
                fromContents ||
                    (yield allMessageContents(this.cms, this.context, yield this.messageContentTypes()));
            for (const fromContent of fromContents) {
                const reachable = yield reachableFrom(this.cms, [fromContent], this.context, this.options);
                for (const r of reachable) {
                    const set = this.referencesTo.get(r.id);
                    if (set) {
                        set.add(fromContent);
                    }
                    else {
                        this.referencesTo.set(r.id, new Set([fromContent]));
                    }
                }
            }
        });
    }
    getReferencesTo(contentId) {
        return this.referencesTo.get(contentId.id) || new Set();
    }
}
exports.MessageContentInverseTraverser = MessageContentInverseTraverser;
function allContents(cms, context, contentTypes) {
    return __awaiter(this, void 0, void 0, function* () {
        const contents = [];
        for (const model of contentTypes) {
            for (const c of yield cms.contents(model, context)) {
                contents.push(c);
            }
        }
        return contents;
    });
}
exports.allContents = allContents;
function allTopContents(cms, context, contentTypes = __1.TOP_CONTENT_TYPES) {
    return __awaiter(this, void 0, void 0, function* () {
        return allContents(cms, context, contentTypes);
    });
}
exports.allTopContents = allTopContents;
function allMessageContents(cms, context, contentTypes = __1.MESSAGE_CONTENT_TYPES) {
    return __awaiter(this, void 0, void 0, function* () {
        return allContents(cms, context, contentTypes);
    });
}
exports.allMessageContents = allMessageContents;
//# sourceMappingURL=message-visitors.js.map