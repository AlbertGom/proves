"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Handoff = exports.HandoffAgentId = exports.HandoffAgentEmail = exports.ScheduleContent = exports.DateRangeContent = exports.Queue = exports.Payload = exports.Url = exports.Chitchat = exports.Text = exports.Image = exports.Document = exports.Element = exports.Carousel = exports.StartUp = exports.Custom = exports.Button = exports.CommonFields = exports.MessageContent = exports.TopContent = exports.Content = exports.Asset = exports.ButtonStyle = void 0;
const objects_1 = require("../util/objects");
const callback_1 = require("./callback");
const cms_1 = require("./cms");
var ButtonStyle;
(function (ButtonStyle) {
    ButtonStyle[ButtonStyle["BUTTON"] = 0] = "BUTTON";
    ButtonStyle[ButtonStyle["QUICK_REPLY"] = 1] = "QUICK_REPLY";
})(ButtonStyle = exports.ButtonStyle || (exports.ButtonStyle = {}));
/** Not a Content because it cannot have custom fields */
class Asset {
    /**
     * @param details depends on the type. eg the image size
     */
    constructor(id, url, info, details) {
        this.id = id;
        this.url = url;
        this.info = info;
        this.details = details;
    }
}
exports.Asset = Asset;
/**
 * Any content deliverable from a CMS.
 * They are immutable, which allows sharing and caching them.
 */
class Content {
    constructor(contentType) {
        this.contentType = contentType;
    }
    /** @return error message if any issue detected */
    validate() {
        return undefined;
    }
    get contentId() {
        return new callback_1.ContentId(this.contentType, this.id);
    }
    toString() {
        return `'${this.id}/${this.name}'`;
    }
    static validateContents(contents) {
        const validations = contents.map(c => {
            const validation = c.validate();
            if (!validation) {
                return validation;
            }
            return `${c.contentType} ${c.toString()}: ${validation}`;
        });
        return this.mergeValidations(validations);
    }
    static mergeValidations(validations) {
        validations = validations.filter(v => v);
        if (validations.length == 0) {
            return undefined;
        }
        return validations.join('. ');
    }
}
exports.Content = Content;
/**
 * A self-contained content with {@link CommonFields}
 */
class TopContent extends Content {
    constructor(common, contentType) {
        super(contentType);
        this.common = common;
        this.contentType = contentType;
    }
    get name() {
        return this.common.name;
    }
    get id() {
        return this.common.id;
    }
    get contentId() {
        return new callback_1.TopContentId(this.contentType, this.id);
    }
    isSearchable() {
        return this.common.keywords.length > 0 || Boolean(this.common.searchableBy);
    }
}
exports.TopContent = TopContent;
/**
 * Contents which have a correspondent Botonic React Message
 */
class MessageContent extends TopContent {
    constructor(common, contentType) {
        super(common, contentType);
        this.common = common;
        this.contentType = contentType;
    }
    findRecursively(predicate) {
        if (predicate(this)) {
            return this;
        }
        if (!this.common.followUp) {
            return undefined;
        }
        return this.common.followUp.findRecursively(predicate);
    }
    cloneWithFollowUp(newFollowUp) {
        const clone = objects_1.shallowClone(this);
        clone.common = objects_1.shallowClone(clone.common);
        clone.common.followUp = newFollowUp;
        return clone;
    }
    cloneWithFollowUpLast(lastContent) {
        if (!this.common.followUp) {
            return this.cloneWithFollowUp(lastContent);
        }
        const followUp = this.common.followUp.cloneWithFollowUpLast(lastContent);
        return this.cloneWithFollowUp(followUp);
    }
    validate() {
        // shortText only validated when it's searchable, since
        // it's only required so far to show text on buttons which
        // refer to this content
        if (this.isSearchable() && !this.common.shortText) {
            return `is searchable but has no shortText`;
        }
        return undefined;
    }
}
exports.MessageContent = MessageContent;
/**
 * When any {@link keywords} is detected on a user input, we can use display the {@link shortText} for users
 * to confirm their interest on this content
 */
class CommonFields {
    constructor(id, name, opt) {
        this.id = id;
        this.name = name;
        if (opt) {
            this.shortText = opt.shortText || '';
            this.keywords = opt.keywords || [];
            this.searchableBy = opt.searchableBy;
            this.partitions = opt.partitions || [];
            this.dateRange = opt.dateRange;
            this.followUp = opt.followUp;
        }
        else {
            this.shortText = '';
            this.keywords = [];
            this.partitions = [];
        }
        this.customFields = (opt === null || opt === void 0 ? void 0 : opt.customFields) || {};
    }
    toString() {
        return `'${this.id}/${this.name}'`;
    }
}
exports.CommonFields = CommonFields;
/**
 * In CMS, there are 2 options to store the buttons:
 * 1) To have direct references to the target content opened by the button
 * 2) To have intermediate button contents which reference
 * the target and allow the button to have a text different than the target content's
 * shortText.
 *
 * Option 1 has these advantages:
 * - The contents also needs the shortText to display a button to disambiguate when
 * the bot does NLU based on the content keywords.
 * - It simplifies adding and removing a button (it's only a link to another content)
 * - It avoids duplication of texts (specially for targets with many sources and many languages)
 * - It simplifies the i18n (the text of the button is more related to the target content that to the source one)
 */
class Button extends Content {
    /**
     * @param id If content having the button has a direct reference to the target
     * content instead of a Button content, the id will be the id of the target.
     * If content having the button has a reference to a Button content, id will
     * be the id of the Button content
     */
    constructor(id, name, text, callback) {
        super(cms_1.ContentType.BUTTON);
        this.id = id;
        this.name = name;
        this.callback = callback;
        this.usingNameForText = !text;
        this.text = text || this.name;
    }
    validate() {
        if (this.usingNameForText) {
            return this.name
                ? `without short text. Using instead 'name' field. `
                : `without short text nor name.`;
        }
        return undefined;
    }
    isDirectReferenceToTarget() {
        return (this.callback instanceof callback_1.ContentCallback && this.callback.id == this.id);
    }
    toString() {
        if (this.isDirectReferenceToTarget()) {
            return `to ${this.callback.toString()}`;
        }
        return `${super.toString()} to content ${this.callback.toString()}`;
    }
    cloneWithText(newText) {
        const clone = objects_1.shallowClone(this);
        clone.text = newText;
        return clone;
    }
}
exports.Button = Button;
class Custom extends Content {
    constructor(id, name, fields = {}) {
        super(cms_1.CustomContentType.CUSTOM);
        this.id = id;
        this.name = name;
        this.fields = fields;
    }
}
exports.Custom = Custom;
class StartUp extends MessageContent {
    constructor(common, imgUrl, text, buttons) {
        super(common, cms_1.ContentType.STARTUP);
        this.common = common;
        this.imgUrl = imgUrl;
        this.text = text;
        this.buttons = buttons;
    }
    validate() {
        const noText = !this.text ? `has no text` : undefined;
        const noButtonsNoFollowUp = !this.buttons.length && !this.common.followUp
            ? 'has no buttons nor follow up'
            : undefined;
        return Content.mergeValidations([
            noText,
            noButtonsNoFollowUp,
            Content.validateContents(this.buttons),
        ]);
    }
    cloneWithText(newText) {
        const clone = objects_1.shallowClone(this);
        clone.text = newText;
        return clone;
    }
    cloneWithButtons(buttons) {
        const clone = objects_1.shallowClone(this);
        clone.buttons = buttons;
        return clone;
    }
}
exports.StartUp = StartUp;
class Carousel extends MessageContent {
    constructor(common, elements = []) {
        super(common, cms_1.ContentType.CAROUSEL);
        this.common = common;
        this.elements = elements;
    }
    validate() {
        if (this.elements.length == 0) {
            return 'has no elements';
        }
        return Content.validateContents(this.elements);
    }
    cloneWithElements(elements) {
        const clone = objects_1.shallowClone(this);
        clone.elements = elements;
        return clone;
    }
}
exports.Carousel = Carousel;
/** Part of a carousel */
class Element extends Content {
    constructor(id, buttons, title, subtitle = '', imgUrl = '') {
        super(cms_1.ContentType.ELEMENT);
        this.id = id;
        this.buttons = buttons;
        this.title = title;
        this.subtitle = subtitle;
        this.imgUrl = imgUrl;
        if (!title && !subtitle && !imgUrl) {
            // TODO throw an exception when CsvExport is fixed (@see IgnoreFallbackDecorator)
            console.error(`Element '${id}' should have title, subtitle or image URL`);
        }
        this.name = title || '';
    }
    validate() {
        return Content.validateContents(this.buttons);
    }
    cloneWithButtons(buttons) {
        const clone = objects_1.shallowClone(this);
        clone.buttons = buttons;
        return clone;
    }
}
exports.Element = Element;
class Document extends MessageContent {
    constructor(common, docUrl) {
        super(common, cms_1.ContentType.DOCUMENT);
        this.common = common;
        this.docUrl = docUrl;
    }
}
exports.Document = Document;
class Image extends MessageContent {
    constructor(common, imgUrl) {
        super(common, cms_1.ContentType.IMAGE);
        this.common = common;
        this.imgUrl = imgUrl;
    }
}
exports.Image = Image;
class Text extends MessageContent {
    constructor(common, 
    // Full text
    text, buttons, buttonsStyle) {
        super(common, cms_1.ContentType.TEXT);
        this.common = common;
        this.text = text;
        this.buttons = buttons;
        this.buttonsStyle = buttonsStyle;
    }
    validate() {
        const noText = !this.text ? `has no text` : undefined;
        return Content.mergeValidations([
            noText,
            super.validate(),
            Content.validateContents(this.buttons),
        ]);
    }
    cloneWithButtons(buttons) {
        const clone = objects_1.shallowClone(this);
        clone.buttons = buttons;
        return clone;
    }
    cloneWithText(newText) {
        const clone = objects_1.shallowClone(this);
        clone.text = newText;
        return clone;
    }
}
exports.Text = Text;
exports.Chitchat = Text;
class Url extends TopContent {
    constructor(common, url) {
        super(common, cms_1.ContentType.URL);
        this.common = common;
        this.url = url;
    }
}
exports.Url = Url;
class Payload extends TopContent {
    constructor(common, payload) {
        super(common, cms_1.ContentType.PAYLOAD);
        this.common = common;
        this.payload = payload;
    }
}
exports.Payload = Payload;
class Queue extends TopContent {
    constructor(common, queue, schedule, handoffMessage) {
        super(common, cms_1.ContentType.QUEUE);
        this.common = common;
        this.queue = queue;
        this.schedule = schedule;
        this.handoffMessage = handoffMessage;
    }
}
exports.Queue = Queue;
class DateRangeContent extends TopContent {
    constructor(common, dateRange) {
        super(common, cms_1.ContentType.DATE_RANGE);
        this.common = common;
        this.dateRange = dateRange;
    }
}
exports.DateRangeContent = DateRangeContent;
class ScheduleContent extends TopContent {
    constructor(common, schedule) {
        super(common, cms_1.ContentType.SCHEDULE);
        this.common = common;
        this.schedule = schedule;
    }
}
exports.ScheduleContent = ScheduleContent;
class HandoffAgentEmail {
    constructor(agentEmail) {
        this.agentEmail = agentEmail;
        this.type = 'AGENT_EMAIL';
    }
}
exports.HandoffAgentEmail = HandoffAgentEmail;
class HandoffAgentId {
    constructor(agentId) {
        this.agentId = agentId;
        this.type = 'AGENT_ID';
    }
}
exports.HandoffAgentId = HandoffAgentId;
/**
 * Most CommonFields make no sense for Handoff.
 * However, we decided to make it a TopContent since it does not depend on other content.
 * Also CommonFields might be potentially useful.
 */
class Handoff extends TopContent {
    constructor(common, onFinish, message, failMessage, 
    //agent and queue are optional because often they are set dynamically by the bot
    queue, agent, shadowing) {
        super(common, cms_1.ContentType.HANDOFF);
        this.common = common;
        this.onFinish = onFinish;
        this.message = message;
        this.failMessage = failMessage;
        this.queue = queue;
        this.agent = agent;
        this.shadowing = shadowing;
    }
    cloneWithQueue(newQueue) {
        const clone = objects_1.shallowClone(this);
        clone.queue = newQueue;
        return clone;
    }
    cloneWithAgent(newAgent) {
        const clone = objects_1.shallowClone(this);
        clone.agent = newAgent;
        return clone;
    }
}
exports.Handoff = Handoff;
//# sourceMappingURL=contents.js.map