import { SearchCandidate } from '../search';
import { ResourceId } from './callback';
import { CMS, ContentType, PagingOptions, TopContentType } from './cms';
import { Asset, Button, Carousel, Chitchat, CommonFields, Content, Custom, DateRangeContent, Document, Element, Handoff, Image, Payload, Queue, ScheduleContent, StartUp, Text, TopContent, Url } from './contents';
import { Context } from './context';
import { CmsException } from './exceptions';
/**
 * It validates the individually delivered contents, but not those fetched
 * through contents/topContents
 */
export declare class ErrorReportingCMS implements CMS {
    readonly cms: CMS;
    readonly logger?: ((msg: string) => void) | undefined;
    private exceptionWrapper;
    constructor(cms: CMS, logger?: ((msg: string) => void) | undefined);
    private validate;
    catchAndValidate<T extends Content>(id: string, context: Context | undefined, contentType: ContentType, promise: Promise<T>): Promise<T>;
    carousel(id: string, context?: Context): Promise<Carousel>;
    document(id: string, context?: Context): Promise<Document>;
    handoff(id: string, context?: Context): Promise<Handoff>;
    custom(id: string, context?: Context): Promise<Custom>;
    text(id: string, context?: Context): Promise<Text>;
    chitchat(id: string, context?: Context): Promise<Chitchat>;
    startUp(id: string, context?: Context): Promise<StartUp>;
    url(id: string, context?: Context): Promise<Url>;
    payload(id: string, context?: Context): Promise<Payload>;
    image(id: string, context?: Context): Promise<Image>;
    queue(id: string, context?: Context): Promise<Queue>;
    button(id: string, context?: Context): Promise<Button>;
    element(id: string, context?: Context): Promise<Element>;
    contentsWithKeywords(context?: Context, paging?: PagingOptions): Promise<SearchCandidate[]>;
    topContents<T extends TopContent>(model: TopContentType, context?: Context, filter?: (cf: CommonFields) => boolean, paging?: PagingOptions): Promise<T[]>;
    content(id: string, context?: Context): Promise<Content>;
    contents<T extends Content>(model: ContentType, context?: Context, paging?: PagingOptions): Promise<T[]>;
    assets(context?: Context): Promise<Asset[]>;
    schedule(id: string, context?: Context): Promise<ScheduleContent>;
    dateRange(id: string, context?: Context): Promise<DateRangeContent>;
    asset(id: string, context?: Context): Promise<Asset>;
    private handleContentError;
    private handleResourceError;
    private handleError;
}
export declare class ContentfulExceptionWrapper {
    readonly wrappee: string;
    readonly logger: (msg: string) => void;
    readonly logStack = true;
    constructor(wrappee: string, logger?: (msg: string) => void);
    wrap(contentfulError: any, method: string, resourceId: ResourceId | undefined, args: Record<string, any>, context: Context | undefined): CmsException;
    processError(contentfulError: Error): string;
}
