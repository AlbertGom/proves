"use strict";
// TODO refactor through conversion of followUp chain to lists of contents
// eg. MessageContent.fromList(content.toList().filter()...map())
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringsFilter = exports.elementsTextFilter = exports.buttonsTextFilter = exports.RecursiveMessageContentFilter = exports.enableDependingOnContext = void 0;
const contents_1 = require("../contents");
const exceptions_1 = require("../exceptions");
const content_factories_1 = require("../factories/content-factories");
function enableDependingOnContext(inFilter, enabler) {
    const filter = (filter) => (c, ctx) => {
        return (enabler(ctx) && filter && filter(c, ctx)) || Promise.resolve(c);
    };
    return {
        carousel: filter(inFilter.carousel),
        image: filter(inFilter.image),
        startUp: filter(inFilter.startUp),
        text: filter(inFilter.text),
    };
}
exports.enableDependingOnContext = enableDependingOnContext;
/**
 * Recursively (through followUps chain) maps a MessageContent to another
 */
class RecursiveMessageContentFilter {
    constructor(filters) {
        this.filters = filters;
    }
    filterContent(content, context) {
        return __awaiter(this, void 0, void 0, function* () {
            context = context || {};
            if (content.common.followUp) {
                const followUp = yield this.filterContent(content.common.followUp, context);
                content = content.cloneWithFollowUp(followUp);
            }
            return (yield this.filterTop(content, context)) || content;
        });
    }
    filterTop(content, context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (content instanceof contents_1.Carousel) {
                return (this.filters.carousel && (yield this.filters.carousel(content, context)));
            }
            if (content instanceof contents_1.Text) {
                return this.filters.text && (yield this.filters.text(content, context));
            }
            if (content instanceof contents_1.StartUp) {
                return this.filters.startUp && this.filters.startUp(content, context);
            }
            if (content instanceof contents_1.Image) {
                return this.filters.image && (yield this.filters.image(content, context));
            }
            throw new exceptions_1.CmsException(`Type '${content.contentType}' not supported`);
        });
    }
}
exports.RecursiveMessageContentFilter = RecursiveMessageContentFilter;
const buttonsTextFilter = (filter) => (buttons) => buttons.map(b => b.cloneWithText(filter(b.text)));
exports.buttonsTextFilter = buttonsTextFilter;
// only applies filter to buttons text
const elementsTextFilter = (filter) => (elements) => elements.map(e => e.cloneWithButtons(exports.buttonsTextFilter(filter)(e.buttons)));
exports.elementsTextFilter = elementsTextFilter;
/**
 * Applies a transformation to all visible string in a MessageContent
 */
const stringsFilter = (filter) => {
    const filterButtons = exports.buttonsTextFilter(filter);
    return {
        text: (text) => {
            return Promise.resolve(text
                .cloneWithText(filter(text.text))
                .cloneWithButtons(filterButtons(text.buttons)));
        },
        carousel: (carousel) => {
            const elements = carousel.elements.map(e => {
                const element = new content_factories_1.ElementBuilder(e.id)
                    .withButtons(filterButtons(e.buttons))
                    .withTitle(filter(e.title))
                    .withSubtitle(filter(e.subtitle))
                    .withImgUrl(e.imgUrl)
                    .build();
                return element;
            });
            return Promise.resolve(carousel.cloneWithElements(elements));
        },
        startUp: (startUp) => {
            return Promise.resolve(startUp
                .cloneWithText(filter(startUp.text))
                .cloneWithButtons(filterButtons(startUp.buttons)));
        },
    };
};
exports.stringsFilter = stringsFilter;
//# sourceMappingURL=message-content-filters.js.map