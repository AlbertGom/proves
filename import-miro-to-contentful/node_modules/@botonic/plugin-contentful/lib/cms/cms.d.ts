import { SearchCandidate } from '../search/search-result';
import { Asset, Button, Carousel, Chitchat, CommonFields, Content, Custom, DateRangeContent, Document, Element, Handoff, Image, Payload, Queue, ScheduleContent, StartUp, Text, TopContent, Url } from './contents';
import { Context } from './context';
export declare enum MessageContentType {
    CAROUSEL = "carousel",
    CHITCHAT = "chitchat",
    DOCUMENT = "document",
    IMAGE = "image",
    TEXT = "text",
    STARTUP = "startUp"
}
export declare const MESSAGE_CONTENT_TYPES: MessageContentType[];
export declare enum NonMessageTopContentType {
    DATE_RANGE = "dateRange",
    HANDOFF = "handoff",
    QUEUE = "queue",
    SCHEDULE = "schedule",
    URL = "url",
    PAYLOAD = "payload"
}
export declare type TopContentType = MessageContentType | NonMessageTopContentType;
export declare const TopContentType: {
    DATE_RANGE: NonMessageTopContentType.DATE_RANGE;
    HANDOFF: NonMessageTopContentType.HANDOFF;
    QUEUE: NonMessageTopContentType.QUEUE;
    SCHEDULE: NonMessageTopContentType.SCHEDULE;
    URL: NonMessageTopContentType.URL;
    PAYLOAD: NonMessageTopContentType.PAYLOAD;
    CAROUSEL: MessageContentType.CAROUSEL;
    CHITCHAT: MessageContentType.CHITCHAT;
    DOCUMENT: MessageContentType.DOCUMENT;
    IMAGE: MessageContentType.IMAGE;
    TEXT: MessageContentType.TEXT;
    STARTUP: MessageContentType.STARTUP;
};
export declare const TOP_CONTENT_TYPES: TopContentType[];
export declare enum SubContentType {
    BUTTON = "button",
    ELEMENT = "element"
}
export declare enum CustomContentType {
    CUSTOM = "custom"
}
export declare type ContentType = TopContentType | SubContentType | CustomContentType;
export declare const ContentType: {
    BUTTON: SubContentType.BUTTON;
    ELEMENT: SubContentType.ELEMENT;
    DATE_RANGE: NonMessageTopContentType.DATE_RANGE;
    HANDOFF: NonMessageTopContentType.HANDOFF;
    QUEUE: NonMessageTopContentType.QUEUE;
    SCHEDULE: NonMessageTopContentType.SCHEDULE;
    URL: NonMessageTopContentType.URL;
    PAYLOAD: NonMessageTopContentType.PAYLOAD;
    CAROUSEL: MessageContentType.CAROUSEL;
    CHITCHAT: MessageContentType.CHITCHAT;
    DOCUMENT: MessageContentType.DOCUMENT;
    IMAGE: MessageContentType.IMAGE;
    TEXT: MessageContentType.TEXT;
    STARTUP: MessageContentType.STARTUP;
};
export declare const CONTENT_TYPES: ContentType[];
export declare enum AssetType {
    AUDIO = "audio",
    IMAGE = "image",
    VIDEO = "video",
    DOCUMENT = "document",
    SPREADSHEET = "spreadsheet",
    OTHER = "other"
}
export declare type ResourceType = ContentType | AssetType;
export declare const ResourceType: {
    AUDIO: AssetType.AUDIO;
    IMAGE: AssetType.IMAGE;
    VIDEO: AssetType.VIDEO;
    DOCUMENT: AssetType.DOCUMENT;
    SPREADSHEET: AssetType.SPREADSHEET;
    OTHER: AssetType.OTHER;
    BUTTON: SubContentType.BUTTON;
    ELEMENT: SubContentType.ELEMENT;
    DATE_RANGE: NonMessageTopContentType.DATE_RANGE;
    HANDOFF: NonMessageTopContentType.HANDOFF;
    QUEUE: NonMessageTopContentType.QUEUE;
    SCHEDULE: NonMessageTopContentType.SCHEDULE;
    URL: NonMessageTopContentType.URL;
    PAYLOAD: NonMessageTopContentType.PAYLOAD;
    CAROUSEL: MessageContentType.CAROUSEL;
    CHITCHAT: MessageContentType.CHITCHAT;
    TEXT: MessageContentType.TEXT;
    STARTUP: MessageContentType.STARTUP;
};
export declare type BotonicContentType = MessageContentType | SubContentType;
export declare const BotonicContentType: {
    BUTTON: SubContentType.BUTTON;
    ELEMENT: SubContentType.ELEMENT;
    CAROUSEL: MessageContentType.CAROUSEL;
    CHITCHAT: MessageContentType.CHITCHAT;
    DOCUMENT: MessageContentType.DOCUMENT;
    IMAGE: MessageContentType.IMAGE;
    TEXT: MessageContentType.TEXT;
    STARTUP: MessageContentType.STARTUP;
};
export declare const BOTONIC_CONTENT_TYPES: BotonicContentType[];
export declare function isCustomModel(cmsModelType: ContentType, localModelType: ContentType): boolean;
export declare function isSameModel(model1: ContentType, model2: ContentType): boolean;
export declare class PagingOptions {
    readonly limit: number;
    readonly skip: number;
    constructor(limit?: number, skip?: number);
}
/**
 * Except for {@link topContents} and {@link contentsWithKeywords}, when {@link Context.locale} is specified it will default
 * to the fallback locale for those fields not available in the specified locale.
 * TODO split in several interfaces. One only for delivering single Content? or only MessageContents? Rename to Delivery
 */
export interface CMS {
    button(id: string, context?: Context): Promise<Button>;
    /**
     * If ContentfulOptions.resumeErrors is set:
     * - If any image cannot be retrieved, it will be left undefined
     * - If any element cannot be retrieved, only the rest will be returned
     */
    carousel(id: string, context?: Context): Promise<Carousel>;
    document(id: string, context?: Context): Promise<Document>;
    chitchat(id: string, context?: Context): Promise<Chitchat>;
    element(id: string, context?: Context): Promise<Element>;
    handoff(id: string, context?: Context): Promise<Handoff>;
    custom(id: string, context?: Context): Promise<Custom>;
    /** Even if ContentfulOptions.resumeErrors is set, if the asset is not available
     * the method will fail. */
    image(id: string, context?: Context): Promise<Image>;
    queue(id: string, context?: Context): Promise<Queue>;
    /**
     * If ContentfulOptions.resumeErrors is set: If the image cannot be retrieved,
     * it will be left undefined
     */
    startUp(id: string, context?: Context): Promise<StartUp>;
    text(id: string, context?: Context): Promise<Text>;
    url(id: string, context?: Context): Promise<Url>;
    payload(id: string, context?: Context): Promise<Payload>;
    /**
     * If locale specified in context, it does not return contents without values for the locale (even if it has value for the fallback locale)
     *
     * If ContentfulOptions.resumeErrors is set: if some contents fail to be devilered,
     * an error will be displayed but the result will be returned.
     */
    topContents<T extends TopContent>(model: TopContentType, context?: Context, filter?: (cf: CommonFields) => boolean, paging?: PagingOptions): Promise<T[]>;
    content(id: string, context?: Context): Promise<Content>;
    /**
     * If ContentfulOptions.resumeErrors is set: if some contents fail to be delivered,
     * an error will be displayed but the result will be returned.
     */
    contents<T extends Content>(model: ContentType, context?: Context, paging?: PagingOptions): Promise<T[]>;
    assets(context?: Context, paging?: PagingOptions): Promise<Asset[]>;
    /**
     * For contents with 'Searchable by' field (eg. {@link Queue}), it returns one result per each 'Seachable by' entry
     * @param context If locale specified, it does not return contents without values for the locale (even if it has value for the fallback locale)
     */
    contentsWithKeywords(context?: Context, paging?: PagingOptions): Promise<SearchCandidate[]>;
    schedule(id: string, context?: Context): Promise<ScheduleContent>;
    dateRange(id: string, context?: Context): Promise<DateRangeContent>;
    asset(id: string, context?: Context): Promise<Asset>;
}
