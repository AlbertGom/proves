"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BotonicMsgConverter = exports.RenderOptions = void 0;
const cms = __importStar(require("../cms"));
const cms_1 = require("../cms");
class RenderOptions {
    constructor() {
        this.followUpDelaySeconds = 4;
        this.maxButtons = 3;
        this.maxQuickReplies = 5;
        this.defaultButtonsStyle = cms_1.ButtonStyle.BUTTON;
    }
}
exports.RenderOptions = RenderOptions;
class BotonicMsgConverter {
    constructor(options = {}) {
        this.options = Object.assign(Object.assign({}, new RenderOptions()), options);
    }
    convert(content, delayS = 0) {
        if (content instanceof cms.Carousel) {
            return this.carousel(content, delayS);
        }
        if (content instanceof cms.Text) {
            return this.text(content, delayS);
        }
        if (content instanceof cms.StartUp) {
            return this.startUp(content, delayS);
        }
        if (content instanceof cms.Image) {
            return this.image(content, delayS);
        }
        if (content instanceof cms.Document) {
            return this.document(content, delayS);
        }
        throw new cms_1.CmsException(`Unsupported content type ${content.contentType}`);
    }
    carousel(carousel, delayS = 0) {
        const msg = {
            type: 'carousel',
            delay: delayS,
            data: {
                elements: carousel.elements.map(e => this.element(e)),
            },
        };
        return this.appendFollowUp(msg, carousel);
    }
    element(cmsElement) {
        return {
            img: cmsElement.imgUrl,
            title: this.str(cmsElement.title),
            subtitle: this.str(cmsElement.subtitle),
            buttons: this.convertButtons(cmsElement.buttons, cms_1.ButtonStyle.BUTTON),
        };
    }
    convertButtons(cmsButtons, style) {
        const maxButtons = style == cms_1.ButtonStyle.BUTTON
            ? this.options.maxButtons
            : this.options.maxQuickReplies;
        if (cmsButtons.length > maxButtons) {
            console.error('Content has more buttons than maximum. Trimming');
            cmsButtons = cmsButtons.slice(0, maxButtons);
        }
        return cmsButtons.map(cmsButton => {
            const msgButton = {
                payload: cmsButton.callback.payload,
                url: cmsButton.callback.url,
            };
            if (style == cms_1.ButtonStyle.BUTTON) {
                msgButton['title'] = this.str(cmsButton.text);
            }
            else {
                msgButton['text'] = this.str(cmsButton.text);
            }
            return msgButton;
        });
    }
    text(text, delayS = 0) {
        const msg = {
            type: 'text',
            delay: delayS,
            data: { text: this.str(text.text) },
        };
        const buttonsStyle = text.buttonsStyle || this.options.defaultButtonsStyle;
        const buttons = this.convertButtons(text.buttons, buttonsStyle);
        if (buttonsStyle == cms_1.ButtonStyle.QUICK_REPLY) {
            msg['replies'] = buttons;
        }
        else {
            msg['buttons'] = buttons;
        }
        return this.appendFollowUp(msg, text);
    }
    startUp(startUp, delayS = 0) {
        const img = {
            type: 'image',
            delay: delayS,
            data: { image: startUp.imgUrl },
        };
        const text = {
            type: 'text',
            data: { text: this.str(startUp.text) },
            buttons: this.convertButtons(startUp.buttons, cms_1.ButtonStyle.BUTTON),
        };
        return this.appendFollowUp([img, text], startUp);
    }
    image(img, delayS = 0) {
        const msg = {
            type: 'image',
            delay: delayS,
            data: {
                image: img.imgUrl,
            },
        };
        return this.appendFollowUp(msg, img);
    }
    document(doc, delayS = 0) {
        const msg = {
            type: 'document',
            delay: delayS,
            data: {
                document: doc.docUrl,
            },
        };
        return this.appendFollowUp(msg, doc);
    }
    appendFollowUp(contentMsgs, content) {
        if (content.common.followUp) {
            const followUp = this.followUp(content.common.followUp);
            const followUps = Array.isArray(followUp) ? followUp : [followUp];
            if (Array.isArray(contentMsgs)) {
                contentMsgs.push(...followUps);
            }
            else {
                contentMsgs = [contentMsgs, ...followUps];
            }
            return contentMsgs;
        }
        return contentMsgs;
    }
    followUp(followUp) {
        if (followUp instanceof cms.Text) {
            // give user time to read the initial text
            return this.text(followUp, this.options.followUpDelaySeconds);
        }
        else if (followUp instanceof cms.Carousel) {
            // for carousels, the previous text usually introduces the carousel. So, we set a smaller delay
            return this.carousel(followUp, 2);
        }
        else if (followUp instanceof cms.Image) {
            return this.image(followUp);
        }
        else if (followUp instanceof cms.StartUp) {
            return this.startUp(followUp);
        }
        else {
            throw new Error('Unexpected followUp type ' + typeof followUp);
        }
    }
    str(str) {
        if (this.options.replaceEmptyStringsWith == undefined) {
            return str;
        }
        return str || this.options.replaceEmptyStringsWith;
    }
}
exports.BotonicMsgConverter = BotonicMsgConverter;
//# sourceMappingURL=botonic-converter.js.map