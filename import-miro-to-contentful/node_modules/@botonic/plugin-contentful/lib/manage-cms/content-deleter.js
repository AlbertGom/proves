"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentDeleter = void 0;
const cms_1 = require("../cms");
const message_visitors_1 = require("../cms/visitors/message-visitors");
const fields_1 = require("./fields");
/**
 * Deletes fields and the references from other contents that reference the
 * content through a button.
 */
class ContentDeleter {
    constructor(manageCms, inverseTraverser, context) {
        this.manageCms = manageCms;
        this.inverseTraverser = inverseTraverser;
        this.context = context;
    }
    deleteContent(contentId, name) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(`Deleting fields and references to ${contentId.toString()} ${String(name)} for locale ${this.context.locale}`);
            yield this.deleteFields(contentId);
            yield this.deleteReferencesTo(contentId);
        });
    }
    deleteFields(contentId) {
        return __awaiter(this, void 0, void 0, function* () {
            const fields = fields_1.getFieldsForContentType(contentId.model);
            const newVal = {};
            for (const field of fields) {
                const f = fields_1.CONTENT_FIELDS.get(field);
                if (!f.isLocalized)
                    continue;
                newVal[field] = undefined;
            }
            yield this.manageCms.updateFields(this.context, contentId, newVal);
        });
    }
    deleteReferencesTo(contentId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.inverseTraverser.isLoaded()) {
                yield this.inverseTraverser.load();
            }
            const sourceContents = this.inverseTraverser.getReferencesTo(contentId);
            for (const source of sourceContents) {
                const referenceStr = `Button from ${source.toString()} to ${contentId.toString()}`;
                const originalButtons = message_visitors_1.getButtons(source);
                if (originalButtons.filter(b => !(b.callback instanceof cms_1.ContentCallback))
                    .length) {
                    console.error(`${referenceStr} cannot be updated because a button contains a payload.` +
                        ' Remove it manually');
                    continue;
                }
                const buttons = originalButtons
                    .filter(b => !b.callback.equals(cms_1.ContentCallback.ofContentId(contentId)))
                    .map(b => ({
                    sys: {
                        type: 'Link',
                        linkType: 'Entry',
                        id: b.callback.id,
                    },
                }));
                if (buttons.length == originalButtons.length) {
                    console.error(`${referenceStr} not found`);
                    continue;
                }
                // TODO do it in parallel
                yield this.manageCms.updateFields(this.context, source.contentId, {
                    [fields_1.ContentFieldType.BUTTONS]: buttons,
                });
            }
        });
    }
}
exports.ContentDeleter = ContentDeleter;
//# sourceMappingURL=content-deleter.js.map