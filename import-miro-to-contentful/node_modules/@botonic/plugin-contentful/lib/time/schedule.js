"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HourAndMinute = exports.TimeRange = exports.WeekDay = exports.DaySchedule = exports.ScheduleAlwaysOn = exports.Schedule = void 0;
const moment_timezone_1 = __importDefault(require("moment-timezone"));
const timezones_1 = require("./timezones");
/**
 * Manages ranges of hour/minutes for each day of a week.
 * The hour/minutes refer to the specified timezone.
 * Use {@link addException} to add holidays (eg with empty {@link TimeRange}) or sales openings in weekends
 * TODO consider using everywhere Date.toLocaleTimeString() to remove moment-timezone dependency
 */
class Schedule {
    constructor(tzName) {
        this.scheduleByDay = new Map();
        this.exceptions = [];
        const zone = moment_timezone_1.default.tz.zone(tzName);
        if (!zone) {
            throw new Error(`${tzName} is not a valid timezone name`);
        }
        this.zone = zone;
    }
    createHourAndMinute(hour, minute = 0) {
        return new HourAndMinute(hour, minute);
    }
    addDaySchedule(weekday, daySchedule) {
        this.scheduleByDay.set(weekday, daySchedule);
        return this;
    }
    /**
     * For the specified date, the weekly schedule will be superseded by the daySchedule specified here
     */
    addException(date, daySchedule) {
        this.exceptions.push(new ExceptionSchedule(date, daySchedule));
        return this;
    }
    /**
     * Formats the specified date using the {@link Schedule}'s timezone.
     * @param locales don't confuse with timezone. This is just to format the date
     */
    timeInThisTimezone(locales, date = new Date()) {
        const options = {
            timeZone: this.zone.name,
            hour12: false,
        };
        return date.toLocaleTimeString(locales, options);
    }
    contains(inDate) {
        const offset = timezones_1.offsetWithTimeZone(this.zone, inDate);
        const scheduleZoneDate = new Date(inDate.getTime() + offset);
        const exception = this.exceptions.find(exception => isSameDay(scheduleZoneDate, exception.date));
        if (exception) {
            return exception.daySchedule.contains(scheduleZoneDate);
        }
        const weekDay = scheduleZoneDate.getDay();
        const schedule = this.scheduleByDay.get(weekDay);
        if (!schedule) {
            return false;
        }
        return schedule.contains(scheduleZoneDate);
    }
}
exports.Schedule = Schedule;
Schedule.TZ_CET = 'Europe/Madrid';
class ScheduleAlwaysOn extends Schedule {
    constructor() {
        super('UTC');
    }
    contains(date) {
        return true;
    }
}
exports.ScheduleAlwaysOn = ScheduleAlwaysOn;
class DaySchedule {
    constructor(ranges) {
        this.ranges = ranges;
    }
    contains(date) {
        for (const range of this.ranges) {
            if (range.contains(date)) {
                return true;
            }
        }
        return false;
    }
}
exports.DaySchedule = DaySchedule;
var WeekDay;
(function (WeekDay) {
    WeekDay[WeekDay["SUNDAY"] = 0] = "SUNDAY";
    WeekDay[WeekDay["MONDAY"] = 1] = "MONDAY";
    WeekDay[WeekDay["TUESDAY"] = 2] = "TUESDAY";
    WeekDay[WeekDay["WEDNESDAY"] = 3] = "WEDNESDAY";
    WeekDay[WeekDay["THURSDAY"] = 4] = "THURSDAY";
    WeekDay[WeekDay["FRIDAY"] = 5] = "FRIDAY";
    WeekDay[WeekDay["SATURDAY"] = 6] = "SATURDAY";
})(WeekDay = exports.WeekDay || (exports.WeekDay = {}));
class ExceptionSchedule {
    constructor(date, daySchedule) {
        this.date = date;
        this.daySchedule = daySchedule;
    }
}
class TimeRange {
    /**
     * @param from inclusive
     * @param to exclusive if 00:00, it will be interpreted as 24:00
     */
    constructor(from, to) {
        this.from = from;
        this.to = to.isMidnight() ? new HourAndMinute(24, 0) : to;
        if (this.from.compare(this.to) >= 0) {
            throw new Error(`${from.toString()} should be before ${to.toString()}`);
        }
    }
    contains(date) {
        if (this.from.compareToDate(date) > 0) {
            return false;
        }
        return this.to.compareToDate(date) > 0;
    }
}
exports.TimeRange = TimeRange;
class HourAndMinute {
    constructor(hour, minute = 0) {
        this.hour = hour;
        this.minute = minute;
    }
    compareToDate(date) {
        return HourAndMinute.compareNumber(this.toMinutes(), date.getHours() * 60 + date.getMinutes());
    }
    isMidnight() {
        return this.hour === 0 && this.minute === 0;
    }
    static compareNumber(first, second) {
        if (first === second) {
            return 0;
        }
        if (first < second) {
            return -1;
        }
        return 1;
    }
    compare(other) {
        return HourAndMinute.compareNumber(this.toMinutes(), other.toMinutes());
    }
    toMinutes() {
        return this.hour * 60 + this.minute;
    }
    toString() {
        let str = this.hour.toString();
        if (this.minute != 0) {
            str += ':' + this.minute.toString();
        }
        return str + 'h';
    }
}
exports.HourAndMinute = HourAndMinute;
// BUG should check date in schedule timezone
function isSameDay(d1, d2) {
    return (d1.getFullYear() === d2.getFullYear() &&
        d1.getMonth() === d2.getMonth() &&
        d1.getDate() === d2.getDate());
}
//# sourceMappingURL=schedule.js.map